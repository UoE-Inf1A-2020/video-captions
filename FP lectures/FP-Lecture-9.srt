1
00:00:00,260 --> 00:00:03,790
Are there any questions?

2
00:00:05,330 --> 00:00:09,990
No. Okay. I'll a couple
of people came up

3
00:00:09,990 --> 00:00:12,000
with really good
questions last time

4
00:00:12,000 --> 00:00:14,249
that I'm sure would have
confused other people.

5
00:00:14,249 --> 00:00:15,554
So I will remind you,

6
00:00:15,554 --> 00:00:17,219
if you have a question,

7
00:00:17,219 --> 00:00:19,770
do not save it till after class.

8
00:00:19,770 --> 00:00:22,664
Ask it in class if you're
confused about something,

9
00:00:22,664 --> 00:00:24,150
surely there are other people

10
00:00:24,150 --> 00:00:25,575
confused about the same thing.

11
00:00:25,575 --> 00:00:28,109
If you will help them and
help yourself and help

12
00:00:28,109 --> 00:00:32,350
me if you ask questions and
somebody now has a question.

13
00:00:45,600 --> 00:00:48,324
Okay, so the question
is how do you write

14
00:00:48,324 --> 00:00:51,324
a Haskell program that
returns prime numbers?

15
00:00:51,324 --> 00:00:56,170
So you can, to check if
a number n is prime,

16
00:00:56,170 --> 00:01:00,009
you can just count
from two up to n minus

17
00:01:00,009 --> 00:01:02,260
one and check whether any of

18
00:01:02,260 --> 00:01:04,899
those things divide and evenly.

19
00:01:04,899 --> 00:01:06,445
So you just check whether,

20
00:01:06,445 --> 00:01:10,075
so for d drawn from two up to n,

21
00:01:10,075 --> 00:01:14,980
is n div and mod d equal to 0.

22
00:01:14,980 --> 00:01:17,935
If so, it's not prime.

23
00:01:17,935 --> 00:01:23,305
So you could use and
to work that out.

24
00:01:23,305 --> 00:01:26,530
And then, and then

25
00:01:26,530 --> 00:01:29,139
you can just check each
number to see if it's prime.

26
00:01:29,139 --> 00:01:31,809
That's not the most efficient
way, but that works.

27
00:01:31,809 --> 00:01:34,765
There's also something called
the sieve of Aristophanes.

28
00:01:34,765 --> 00:01:37,780
Aristophanes, which you can

29
00:01:37,780 --> 00:01:40,734
write in Haskell in
a really cool way

30
00:01:40,734 --> 00:01:43,120
because the SIV is about
taking the infinite list of

31
00:01:43,120 --> 00:01:44,800
all numbers and then crossing

32
00:01:44,800 --> 00:01:46,645
out all the ones
that aren't prime.

33
00:01:46,645 --> 00:01:48,925
And I'll let you look
that went up online.

34
00:01:48,925 --> 00:01:51,595
So sieve of Aristophanes is

35
00:01:51,595 --> 00:01:55,059
your friend if you want
to do primes in Haskell.

36
00:01:55,059 --> 00:01:56,980
Okay. Any other questions?

37
00:01:56,980 --> 00:02:05,469
Yes. Can you use map,

38
00:02:05,469 --> 00:02:08,700
filter and fold for?

39
00:02:08,700 --> 00:02:11,779
So typically use a
lambda to provide

40
00:02:11,779 --> 00:02:15,409
an argument to map
or filter or fold.

41
00:02:15,409 --> 00:02:17,540
So are you asking in
the body of a lambda,

42
00:02:17,540 --> 00:02:20,459
can you write map filter or fall?

43
00:02:20,560 --> 00:02:23,389
Right in the body of a lambda?

44
00:02:23,389 --> 00:02:25,729
You put a term.

45
00:02:25,729 --> 00:02:27,590
I will now tell you something

46
00:02:27,590 --> 00:02:28,940
that's worth jumping up and down

47
00:02:28,940 --> 00:02:32,674
about anywhere you
can my DU term,

48
00:02:32,674 --> 00:02:34,684
you can write head term.

49
00:02:34,684 --> 00:02:36,769
In other words, there
are no restrictions,

50
00:02:36,769 --> 00:02:38,255
so anything can go in there

51
00:02:38,255 --> 00:02:40,759
including map, filter and fold.

52
00:02:40,759 --> 00:02:42,410
But this idea that things are

53
00:02:42,410 --> 00:02:44,150
uniform, that you don't say.

54
00:02:44,150 --> 00:02:45,589
You can write some things here

55
00:02:45,589 --> 00:02:46,925
and some other things here,

56
00:02:46,925 --> 00:02:48,200
and some other things here.

57
00:02:48,200 --> 00:02:50,865
And we have lots of
different special cases.

58
00:02:50,865 --> 00:02:53,139
That's not what you do.

59
00:02:53,139 --> 00:02:56,950
You are trained in
informatics and you

60
00:02:56,950 --> 00:03:02,049
understand that uniformity
and simplicity are a virtue.

61
00:03:02,049 --> 00:03:04,479
So use the same thing everywhere.

62
00:03:04,479 --> 00:03:06,609
Wherever a term can appear,

63
00:03:06,609 --> 00:03:08,710
a term can appear and you

64
00:03:08,710 --> 00:03:10,900
don't have arbitrary
restrictions on.

65
00:03:10,900 --> 00:03:14,304
Thanks. That's a really
important design principle.

66
00:03:14,304 --> 00:03:16,344
So does that answer
your question?

67
00:03:16,344 --> 00:03:17,094
Great.

68
00:03:17,094 --> 00:03:18,589
Yes.

69
00:03:37,690 --> 00:03:39,560
Okay. So you're

70
00:03:39,560 --> 00:03:42,904
noting that the class exams,

71
00:03:42,904 --> 00:03:44,135
the past ones that you've seen,

72
00:03:44,135 --> 00:03:45,695
all begin with a paid saying.

73
00:03:45,695 --> 00:03:48,184
Here are some library functions
you might want to use.

74
00:03:48,184 --> 00:03:49,760
And your question is,

75
00:03:49,760 --> 00:03:52,129
could I use some other
library function?

76
00:03:52,129 --> 00:03:54,125
I wouldn't recommend it.

77
00:03:54,125 --> 00:03:56,120
But I put there the stuff that I

78
00:03:56,120 --> 00:03:58,249
think you should know about.

79
00:03:58,249 --> 00:04:00,650
So you might know
about something else

80
00:04:00,650 --> 00:04:02,884
and it might be legitimate
library function.

81
00:04:02,884 --> 00:04:04,850
And they'll have to go,
what on earth is this?

82
00:04:04,850 --> 00:04:05,900
And tried to mark things if you

83
00:04:05,900 --> 00:04:06,920
want to stick to the stuff

84
00:04:06,920 --> 00:04:09,470
that your markers will
know and understand,

85
00:04:09,470 --> 00:04:12,139
stick to the given
library functions.

86
00:04:12,139 --> 00:04:20,960
Yes. You know,

87
00:04:20,960 --> 00:04:23,059
you can use map and
filter and especially for

88
00:04:23,059 --> 00:04:26,459
the question that says use
map and filter to do this.

89
00:04:27,670 --> 00:04:33,089
Okay? Other questions?

90
00:04:34,150 --> 00:04:41,480
Yes. Is there a
simple explanation

91
00:04:41,480 --> 00:04:43,830
for recursive data types?

92
00:04:48,280 --> 00:04:50,480
So you didn't understand

93
00:04:50,480 --> 00:04:53,999
the recursive definition
of the natural numbers.

94
00:04:58,930 --> 00:05:02,089
Right? So the data type
list of a's defined in

95
00:05:02,089 --> 00:05:04,550
terms of the data type
list of a, right?

96
00:05:04,550 --> 00:05:05,750
You saw that way back,

97
00:05:05,750 --> 00:05:07,860
not to us yesterday.

98
00:05:09,790 --> 00:05:12,515
You also saw it yesterday.

99
00:05:12,515 --> 00:05:14,539
But we we explained
that right back.

100
00:05:14,539 --> 00:05:16,640
My first explained head and tail.

101
00:05:16,640 --> 00:05:20,820
I said the tail of a list
of a is also a list of a.

102
00:05:32,830 --> 00:05:35,719
So we'll see some recursive
data types today.

103
00:05:35,719 --> 00:05:37,760
Let's see if that sort you out.

104
00:05:37,760 --> 00:05:39,950
Okay, so the question is,

105
00:05:39,950 --> 00:05:42,245
I'm confused about
recursive data types.

106
00:05:42,245 --> 00:05:44,239
Let me just check
how many people feel

107
00:05:44,239 --> 00:05:48,840
they've completely understand
recursive data types.

108
00:05:49,090 --> 00:05:51,859
Okay, I'm not sure whether
I should raise my hand.

109
00:05:51,859 --> 00:05:54,454
There are not. How
many people feel

110
00:05:54,454 --> 00:05:55,850
that they are somewhat

111
00:05:55,850 --> 00:05:59,069
confused about
recursive data types,

112
00:05:59,260 --> 00:06:02,479
right? You have lots of company.

113
00:06:02,479 --> 00:06:05,210
So let me give you
another example of

114
00:06:05,210 --> 00:06:08,044
a recursive data type
and let me see if that

115
00:06:08,044 --> 00:06:10,250
helps bring it home because

116
00:06:10,250 --> 00:06:11,630
recursion is one of

117
00:06:11,630 --> 00:06:13,414
the most important
ideas in the course.

118
00:06:13,414 --> 00:06:15,980
So it is important that you
become familiar with it.

119
00:06:15,980 --> 00:06:17,930
But I understand, right?

120
00:06:17,930 --> 00:06:19,279
You have to see a few examples

121
00:06:19,279 --> 00:06:20,659
before it gets driven home.

122
00:06:20,659 --> 00:06:22,444
So let me give you
another example.

123
00:06:22,444 --> 00:06:25,399
So that's the perfect
introduction to today's talk,

124
00:06:25,399 --> 00:06:27,994
which is about expression trees,

125
00:06:27,994 --> 00:06:31,625
which are an example of
a recursive data type.

126
00:06:31,625 --> 00:06:39,890
Ok. So here's the data

127
00:06:39,890 --> 00:06:42,964
to a very simple data
type of expression trees.

128
00:06:42,964 --> 00:06:44,959
So we've got three things.

129
00:06:44,959 --> 00:06:46,609
An expression is either a

130
00:06:46,609 --> 00:06:49,520
literal which has
one thing inside it,

131
00:06:49,520 --> 00:06:52,249
which is an int, or an ad,

132
00:06:52,249 --> 00:06:53,809
which has two things inside it,

133
00:06:53,809 --> 00:06:56,944
which are both
themselves expressions.

134
00:06:56,944 --> 00:07:00,170
Or a multiply which has
two things inside it,

135
00:07:00,170 --> 00:07:03,840
which are both
themselves expressions.

136
00:07:04,200 --> 00:07:07,929
Okay. And notice, right,

137
00:07:07,929 --> 00:07:10,884
this is an instance of the
principal I just described,

138
00:07:10,884 --> 00:07:12,520
which is everywhere in

139
00:07:12,520 --> 00:07:14,470
expression can appear and
expression can appear.

140
00:07:14,470 --> 00:07:17,080
So an expression is one
of these three things.

141
00:07:17,080 --> 00:07:19,360
And then two of them
are themselves built up

142
00:07:19,360 --> 00:07:23,000
out of the exact same
expression type.

143
00:07:24,420 --> 00:07:27,325
So that may seem strange,

144
00:07:27,325 --> 00:07:28,809
but let me show you
some things you

145
00:07:28,809 --> 00:07:30,460
can do with the expressions.

146
00:07:30,460 --> 00:07:32,980
So the first thing is
you can evaluate it.

147
00:07:32,980 --> 00:07:34,720
So if you evaluate an expression,

148
00:07:34,720 --> 00:07:37,420
you get back x.

149
00:07:37,420 --> 00:07:40,299
Actually, let me, let's

150
00:07:40,299 --> 00:07:43,509
just have a look

151
00:07:43,509 --> 00:07:47,060
at phase so that we
can see some examples.

152
00:07:52,260 --> 00:07:54,369
Alright, so I've already loaded

153
00:07:54,369 --> 00:07:56,739
up this definition, right?

154
00:07:56,739 --> 00:07:58,059
It's the exact same definition.

155
00:07:58,059 --> 00:08:00,895
So what are some
examples of expressions?

156
00:08:00,895 --> 00:08:04,615
So somebody give me an
expression using this type.

157
00:08:04,615 --> 00:08:11,664
Yep. Let, yeah, 0.

158
00:08:11,664 --> 00:08:14,935
Good. Somebody else
give me an expression.

159
00:08:14,935 --> 00:08:17,020
And what does that rep,
which expression does that

160
00:08:17,020 --> 00:08:19,989
represent? The number 0.

161
00:08:19,989 --> 00:08:22,910
Ok, somebody else give
me an expression.

162
00:08:24,750 --> 00:08:32,389
Sorry. Let five, good.

163
00:08:35,580 --> 00:08:44,754
Yep. Add let 0.

164
00:08:44,754 --> 00:08:49,795
Lead to good. When more,

165
00:08:49,795 --> 00:08:55,100
Yep. Negative one, good.

166
00:08:56,430 --> 00:08:58,975
One more.

167
00:08:58,975 --> 00:09:09,010
Yep. Mole. Let minus1.

168
00:09:09,010 --> 00:09:13,285
Let negative too.

169
00:09:13,285 --> 00:09:18,449
Good. Another one.
Really big one.

170
00:09:19,540 --> 00:09:21,959
Yep.

171
00:09:30,190 --> 00:09:31,909
So if is

172
00:09:31,909 --> 00:09:33,680
a thing we've got in Haskell,

173
00:09:33,680 --> 00:09:34,910
but it's not a thing we've got

174
00:09:34,910 --> 00:09:36,139
in these expressions, right?

175
00:09:36,139 --> 00:09:38,720
We've only got, LET
add mode for you.

176
00:09:38,720 --> 00:09:40,204
What are you trying to write?

177
00:09:40,204 --> 00:09:43,530
A Haskell turn that
returns an expression.

178
00:09:44,380 --> 00:09:47,824
Ok, so what Haskell term
do you want to write?

179
00:09:47,824 --> 00:09:49,410
If

180
00:10:06,300 --> 00:10:07,569
let

181
00:10:07,569 --> 00:10:08,755
something in something,

182
00:10:08,755 --> 00:10:13,519
okay, let m

183
00:10:14,640 --> 00:10:17,120
n

184
00:10:21,090 --> 00:10:26,515
i in brackets.

185
00:10:26,515 --> 00:10:31,539
Yeah. So what do

186
00:10:31,539 --> 00:10:33,950
you want me to write
between the brackets?

187
00:10:34,620 --> 00:10:44,615
If The function.

188
00:10:44,615 --> 00:10:47,489
What? Email export.

189
00:10:48,910 --> 00:10:51,470
No, we haven't talked

190
00:10:51,470 --> 00:10:54,390
about yet you're not
allowed to use it.

191
00:10:56,170 --> 00:11:00,934
Right? Just using
LET, ad and mol.

192
00:11:00,934 --> 00:11:03,780
Let's write down a large term.

193
00:11:04,390 --> 00:11:07,230
Mall.

194
00:11:15,040 --> 00:11:22,429
Good, add, lit.

195
00:11:22,429 --> 00:11:25,385
Forty-two, Good choice.

196
00:11:25,385 --> 00:11:32,870
And let 0. Okay, good.

197
00:11:32,870 --> 00:11:35,449
Now we've got two functions here.

198
00:11:35,449 --> 00:11:40,880
One of these is this beginning
to become clear to people.

199
00:11:40,880 --> 00:11:43,339
Right? So one of these takes

200
00:11:43,339 --> 00:11:46,280
an expression and
returns its value,

201
00:11:46,280 --> 00:11:47,869
is given an expression,

202
00:11:47,869 --> 00:11:51,109
I can always get a
number out of it.

203
00:11:51,109 --> 00:11:53,869
So if it's a literal
and that's easy,

204
00:11:53,869 --> 00:11:56,239
just returned liberal n. If it's

205
00:11:56,239 --> 00:11:59,690
an add of two
expressions, E and F,

206
00:11:59,690 --> 00:12:05,490
then what we're
going to do one way,

207
00:12:05,670 --> 00:12:10,075
if it's an add of two
expressions, E and F,

208
00:12:10,075 --> 00:12:16,569
then what we're going to do
is recursively evaluate E,

209
00:12:16,569 --> 00:12:21,744
recursively evaluate f, And
what shall I do with them?

210
00:12:21,744 --> 00:12:23,709
Oh, it's called add.

211
00:12:23,709 --> 00:12:26,589
Why don't I add them together?

212
00:12:26,589 --> 00:12:29,394
And similarly for multiply,

213
00:12:29,394 --> 00:12:31,599
we will recursively evaluate

214
00:12:31,599 --> 00:12:34,554
the first one and
evaluate the second one.

215
00:12:34,554 --> 00:12:36,040
And it's called multiply,

216
00:12:36,040 --> 00:12:39,819
so we will multiply
them together.

217
00:12:39,819 --> 00:12:43,600
Okay? Now there's other one,

218
00:12:43,600 --> 00:12:47,805
converts an expression to a
string so we can look at it.

219
00:12:47,805 --> 00:12:50,195
So LET event just shows n,

220
00:12:50,195 --> 00:12:52,579
convert the number n to a string,

221
00:12:52,579 --> 00:12:56,495
add E of f recursively showy.

222
00:12:56,495 --> 00:13:01,399
Then put a plus sign
and recursively show f,

223
00:13:01,399 --> 00:13:04,834
and put some parentheses
around the whole thing.

224
00:13:04,834 --> 00:13:06,499
Multiplies the same.

225
00:13:06,499 --> 00:13:09,950
Showy, then show at times symbol,

226
00:13:09,950 --> 00:13:12,515
then show f, and

227
00:13:12,515 --> 00:13:15,424
recursively put parentheses
around the whole thing.

228
00:13:15,424 --> 00:13:17,149
So let's give some, let's see

229
00:13:17,149 --> 00:13:19,070
some examples of how those work.

230
00:13:19,070 --> 00:13:22,890
Whoops. Go back here.

231
00:13:23,500 --> 00:13:26,090
So the thing that we last had,

232
00:13:26,090 --> 00:13:27,529
Whoops, no, no, no,

233
00:13:27,529 --> 00:13:29,735
no, no, no, no, no, no, no.

234
00:13:29,735 --> 00:13:33,095
Go over here, right? The thing
we last had is called yet.

235
00:13:33,095 --> 00:13:34,625
So I'm just going to type it up.

236
00:13:34,625 --> 00:13:36,469
No. It reloaded it.

237
00:13:36,469 --> 00:13:40,100
Okay. That's okay. There we go.

238
00:13:40,100 --> 00:13:42,740
Here's the last thing we had.

239
00:13:42,740 --> 00:13:44,750
So that's just that.

240
00:13:44,750 --> 00:13:49,519
But I could show
exp of, well, wait,

241
00:13:49,519 --> 00:13:53,284
let's do escape P. And

242
00:13:53,284 --> 00:13:56,794
then I write show XP
around that whole thing.

243
00:13:56,794 --> 00:13:59,129
What am I going to get?

244
00:14:02,050 --> 00:14:07,219
But find out? Let's see.

245
00:14:07,219 --> 00:14:10,100
Is it I'm doing show.

246
00:14:10,100 --> 00:14:12,335
Ok. So why do these three things?

247
00:14:12,335 --> 00:14:18,034
Let DO is an ad is more
or less same as ad,

248
00:14:18,034 --> 00:14:21,904
bc, mole add or
they use the same.

249
00:14:21,904 --> 00:14:26,089
They might be, let's
see. Oh no, they're not.

250
00:14:26,089 --> 00:14:27,290
No, not the same.

251
00:14:27,290 --> 00:14:29,405
Okay. Mole and mole

252
00:14:29,405 --> 00:14:31,790
are the those are the
same. They're the same.

253
00:14:31,790 --> 00:14:33,304
It's this one. It's this one.

254
00:14:33,304 --> 00:14:36,409
Ok. So e is going to be
the first thing after

255
00:14:36,409 --> 00:14:40,894
the mole that's ad of
let phi and lit for,

256
00:14:40,894 --> 00:14:44,000
okay, that e and f is going to

257
00:14:44,000 --> 00:14:48,215
be add of LET 42 and let 0 could.

258
00:14:48,215 --> 00:14:53,930
So now I'm gonna do par of
show extra B and then a times,

259
00:14:53,930 --> 00:14:57,095
then show exp of F. Okay.

260
00:14:57,095 --> 00:15:00,019
Well I got to work out
what your extra V as ok,

261
00:15:00,019 --> 00:15:04,549
so e was add 54.

262
00:15:04,549 --> 00:15:08,254
So let see.

263
00:15:08,254 --> 00:15:12,320
So that'll let know, is it an ad?

264
00:15:12,320 --> 00:15:13,955
It isn't that it is an AD.

265
00:15:13,955 --> 00:15:16,864
So e is going to be five and

266
00:15:16,864 --> 00:15:21,064
f is going to be let
for, oh, you know what?

267
00:15:21,064 --> 00:15:24,290
Haha, ungraded cheat.

268
00:15:24,290 --> 00:15:26,820
I'm just going to
ask the computer.

269
00:15:35,950 --> 00:15:40,685
Right? So that gives five
plus four. Again, why?

270
00:15:40,685 --> 00:15:46,159
Well, because first,

271
00:15:46,159 --> 00:15:49,459
we look at which line it is
and it's the AD line again.

272
00:15:49,459 --> 00:15:52,109
So what's E going
to be this time?

273
00:15:53,590 --> 00:15:58,085
E will be lit five and
F will be lit for.

274
00:15:58,085 --> 00:16:00,799
So we can just do
show exp of those.

275
00:16:00,799 --> 00:16:04,175
So show XP, flip five,

276
00:16:04,175 --> 00:16:05,915
does all the
parentheses are needed.

277
00:16:05,915 --> 00:16:08,479
That's the string five.

278
00:16:08,479 --> 00:16:12,065
Right? So it takes a number
to a string using show

279
00:16:12,065 --> 00:16:16,025
because that's what
this line says to do.

280
00:16:16,025 --> 00:16:25,384
And LET four, what's that
going to be? The string for?

281
00:16:25,384 --> 00:16:31,189
And so now we show those, right?

282
00:16:31,189 --> 00:16:37,865
Then it says it's that
plus that, plus that,

283
00:16:37,865 --> 00:16:39,379
which is five plus four,

284
00:16:39,379 --> 00:16:42,360
and then it's par of that,

285
00:16:42,580 --> 00:16:45,935
which puts parentheses around it.

286
00:16:45,935 --> 00:16:50,075
Okay? So this is why if we
look at the whole thing,

287
00:16:50,075 --> 00:16:54,140
we get five plus four
and then two times,

288
00:16:54,140 --> 00:16:55,609
and then 42 plus 0.

289
00:16:55,609 --> 00:17:00,359
Everything in parentheses
is that clear to everybody?

290
00:17:00,430 --> 00:17:04,679
And then similarly
we can evaluate it.

291
00:17:09,370 --> 00:17:15,289
Escape. So now instead

292
00:17:15,289 --> 00:17:17,794
of show What I'm
gonna do eval exp,

293
00:17:17,794 --> 00:17:20,279
and what's that going to return.

294
00:17:21,220 --> 00:17:24,919
So five plus four is what?

295
00:17:24,919 --> 00:17:28,219
42 plus 0 is what?

296
00:17:28,219 --> 00:17:32,099
And nine times 42 is.

297
00:17:32,830 --> 00:17:35,974
Let's find out what
nine times 42 is.

298
00:17:35,974 --> 00:17:42,469
It's 378. Ok. Is that
clear enough to people?

299
00:17:42,469 --> 00:17:45,289
Do you understand how these
expressions are working?

300
00:17:45,289 --> 00:17:48,199
Okay, and you were worried
about recursion before.

301
00:17:48,199 --> 00:17:50,540
Do you understand it
a bit better now?

302
00:17:50,540 --> 00:17:55,414
And notice we already learned
about recursive functions.

303
00:17:55,414 --> 00:17:57,859
Notice recursive types and

304
00:17:57,859 --> 00:18:01,260
recursive functions go together.

305
00:18:01,390 --> 00:18:08,045
Right? So here the bits

306
00:18:08,045 --> 00:18:10,834
of an ad are both
themselves expressions.

307
00:18:10,834 --> 00:18:15,470
The bits of a mole are both
themselves expressions.

308
00:18:15,470 --> 00:18:20,990
So when we're doing an ad,

309
00:18:20,990 --> 00:18:23,030
right, e is going to
be an expression,

310
00:18:23,030 --> 00:18:24,439
f is going to be expression.

311
00:18:24,439 --> 00:18:28,189
Somehow. We need to turn this
expression into a number.

312
00:18:28,189 --> 00:18:31,580
Oh wait, that's exactly
what eval exp is.

313
00:18:31,580 --> 00:18:36,140
Four. So I can find e
val exp of add a, v,

314
00:18:36,140 --> 00:18:38,209
and f in terms of

315
00:18:38,209 --> 00:18:43,249
eval exp of the e and
e val exp of that.

316
00:18:43,249 --> 00:18:46,460
And again, this works just
like with lists, right?

317
00:18:46,460 --> 00:18:49,219
With lists, you always go
to the tail of the list.

318
00:18:49,219 --> 00:18:51,529
Here we're always going either to

319
00:18:51,529 --> 00:18:53,884
the left subtree or
the right sub tree.

320
00:18:53,884 --> 00:18:57,275
So the tree we're acting
on always gets smaller.

321
00:18:57,275 --> 00:18:58,700
And with lists, you

322
00:18:58,700 --> 00:19:02,615
always eventually reach a
base case which is nil.

323
00:19:02,615 --> 00:19:05,134
And here again, we eventually
reach a base case,

324
00:19:05,134 --> 00:19:07,504
which is the lit case.

325
00:19:07,504 --> 00:19:18,869
Okay? So here are two examples
that I've already run.

326
00:19:19,990 --> 00:19:26,450
So IO is add of two to
multiply three with three.

327
00:19:26,450 --> 00:19:30,079
And e one is multiply add of Lit

328
00:19:30,079 --> 00:19:34,024
two and let three with three.

329
00:19:34,024 --> 00:19:36,800
So that means if we show E 0,

330
00:19:36,800 --> 00:19:38,960
we get open parenthesis two plus

331
00:19:38,960 --> 00:19:41,645
open parentheses
three times three,

332
00:19:41,645 --> 00:19:44,209
close parenthesis,
close parenthesis.

333
00:19:44,209 --> 00:19:46,444
But if we do show y1,

334
00:19:46,444 --> 00:19:47,884
right will get open paren,

335
00:19:47,884 --> 00:19:50,120
open paren 2x plus three

336
00:19:50,120 --> 00:19:53,194
close paren times
three close friends.

337
00:19:53,194 --> 00:19:57,590
You see how E0 and E1 correspond
to these two strings.

338
00:19:57,590 --> 00:20:00,060
Is that clear to everybody?

339
00:20:01,510 --> 00:20:03,559
So some people are nodding

340
00:20:03,559 --> 00:20:05,360
and most people are
going to occur.

341
00:20:05,360 --> 00:20:07,369
So I've asked you to do want to

342
00:20:07,369 --> 00:20:09,080
thank them to look
around the room.

343
00:20:09,080 --> 00:20:12,409
And I want you to either
nod as in yes, I'm bored.

344
00:20:12,409 --> 00:20:13,550
That's completely obvious.

345
00:20:13,550 --> 00:20:17,314
Fill or I want you to raise
your hand and ask a question.

346
00:20:17,314 --> 00:20:20,330
Ok? Do one of those two things.

347
00:20:20,330 --> 00:20:22,939
If you don't know
what question to ask,

348
00:20:22,939 --> 00:20:25,234
you may ask the
following question.

349
00:20:25,234 --> 00:20:27,050
What question should I ask?

350
00:20:27,050 --> 00:20:30,050
That's OK. And then we'll
go on to get somebody else

351
00:20:30,050 --> 00:20:31,100
in the audience to help you

352
00:20:31,100 --> 00:20:32,944
out formulating your question.

353
00:20:32,944 --> 00:20:34,250
But I really want you to do

354
00:20:34,250 --> 00:20:35,810
one of these two things, okay,

355
00:20:35,810 --> 00:20:38,899
so either nod or raise your
hand and ask a question.

356
00:20:38,899 --> 00:20:41,819
So let's startling here.
Are you bored yet?

357
00:20:45,520 --> 00:20:48,170
All right. So far
everybody's normally that

358
00:20:48,170 --> 00:20:50,404
but that guys just
looking at his phone.

359
00:20:50,404 --> 00:20:55,909
Okay. You're just sitting
there with your hands crossed?

360
00:20:55,909 --> 00:21:00,860
The one or the other?
Yes. You nod or raise

361
00:21:00,860 --> 00:21:06,440
your hand or ask

362
00:21:06,440 --> 00:21:09,420
the person next to you what
question you should ask.

363
00:21:11,110 --> 00:21:16,894
Okay. Okay. I'll keep
going around the room up.

364
00:21:16,894 --> 00:21:22,500
Question or question,
shouldn't you ask?

365
00:21:23,200 --> 00:21:30,109
I've no idea. Okay. Let
me keep going round.

366
00:21:30,109 --> 00:21:31,580
People are now look,

367
00:21:31,580 --> 00:21:32,900
if I look at you, please either

368
00:21:32,900 --> 00:21:34,099
not at me or raise your hand.

369
00:21:34,099 --> 00:21:44,249
I'm serious. Good. Yes.

370
00:21:55,210 --> 00:21:58,490
Oh, why did I use plus and times

371
00:21:58,490 --> 00:22:00,139
the built-in ones rather than the

372
00:22:00,139 --> 00:22:01,924
once I defined yesterday,

373
00:22:01,924 --> 00:22:04,340
I could use either one, right?

374
00:22:04,340 --> 00:22:05,899
But they'll work on
different types.

375
00:22:05,899 --> 00:22:08,735
So that was a natural
type, I think I called it.

376
00:22:08,735 --> 00:22:10,100
And these are integers.

377
00:22:10,100 --> 00:22:11,599
So here I've just
decided I'm going to

378
00:22:11,599 --> 00:22:13,340
work with integers, right?

379
00:22:13,340 --> 00:22:15,470
We could do it over
again with like floats.

380
00:22:15,470 --> 00:22:17,570
That would work too. So there's

381
00:22:17,570 --> 00:22:19,459
several different
numeric types and we

382
00:22:19,459 --> 00:22:21,965
get different ones depending
on which one we use.

383
00:22:21,965 --> 00:22:26,675
So here I've decided
it's going to be ints.

384
00:22:26,675 --> 00:22:28,910
And here I've decided
I want to get out and

385
00:22:28,910 --> 00:22:31,699
int by could've
decided say on floats.

386
00:22:31,699 --> 00:22:34,804
That's a good question. Good.

387
00:22:34,804 --> 00:22:42,440
Yep. Why do order of operations?

388
00:22:42,440 --> 00:22:45,124
So that was the point I think
that I want to make to you.

389
00:22:45,124 --> 00:22:47,750
So look why both of these are

390
00:22:47,750 --> 00:22:51,395
two and a plus and a
32 times into three.

391
00:22:51,395 --> 00:22:54,439
But they're very
different, right?

392
00:22:54,439 --> 00:22:56,689
This one means first
multiply three

393
00:22:56,689 --> 00:22:59,434
by three and then add two to it.

394
00:22:59,434 --> 00:23:01,579
But this one means add

395
00:23:01,579 --> 00:23:03,769
two to three and then
multiply it by three.

396
00:23:03,769 --> 00:23:06,719
It's not what you meant
by order of operations.

397
00:23:08,980 --> 00:23:15,439
Here. What would happen if I
omitted all the parentheses?

398
00:23:15,439 --> 00:23:17,585
So if I omitted all
the parentheses here,

399
00:23:17,585 --> 00:23:19,340
school will say I
can't parse that.

400
00:23:19,340 --> 00:23:21,900
I've no idea what
you're talking about.

401
00:23:23,410 --> 00:23:26,254
But so you raised

402
00:23:26,254 --> 00:23:28,820
the next point I wanted
to make, so thank you.

403
00:23:28,820 --> 00:23:32,480
Right. Which is write these
in some sense look the same,

404
00:23:32,480 --> 00:23:36,455
but they are very, very
different. Right? Adhere, right?

405
00:23:36,455 --> 00:23:39,290
It's everything in the same order

406
00:23:39,290 --> 00:23:41,434
with just a few
parentheses different.

407
00:23:41,434 --> 00:23:43,025
But if you look here,

408
00:23:43,025 --> 00:23:44,330
right, it's very different.

409
00:23:44,330 --> 00:23:47,840
This says the top level
thing is an ad, right?

410
00:23:47,840 --> 00:23:49,309
This is the top level thing.

411
00:23:49,309 --> 00:23:50,914
This is the most important.

412
00:23:50,914 --> 00:23:53,630
It's an ad. But this
one says no, no, no.

413
00:23:53,630 --> 00:23:56,030
What we're doing is
multiplying things.

414
00:23:56,030 --> 00:24:01,765
So it begins with a
mole. Do you see that?

415
00:24:01,765 --> 00:24:05,904
Actually? Does anybody
have a sheet of paper?

416
00:24:05,904 --> 00:24:09,565
I should. I can I can use
this to show you something,

417
00:24:09,565 --> 00:24:11,215
but I didn't bring
a sheet of paper.

418
00:24:11,215 --> 00:24:16,405
Yes. And does anybody have a ten?

419
00:24:16,405 --> 00:24:22,884
Right. So it's very
health, right?

420
00:24:22,884 --> 00:24:25,209
I called these things trees.

421
00:24:25,209 --> 00:24:26,979
So why are they called trees?

422
00:24:26,979 --> 00:24:31,959
Because the first one looks
like it's a plus on the top.

423
00:24:31,959 --> 00:24:36,490
And then oh,

424
00:24:36,490 --> 00:24:38,905
you want to actually see
what I'm doing as well?

425
00:24:38,905 --> 00:24:45,414
Okay. There we go.

426
00:24:45,414 --> 00:24:47,184
It's a plus on the top.

427
00:24:47,184 --> 00:24:49,449
And then this is a
two and this is at

428
00:24:49,449 --> 00:24:54,010
times, and this is 33.

429
00:24:54,010 --> 00:24:57,429
And the other one is
at times on the top.

430
00:24:57,429 --> 00:25:00,999
And then a plus here,

431
00:25:00,999 --> 00:25:06,639
and then a two, and then a
three. And then a three.

432
00:25:06,639 --> 00:25:09,099
So those are illustrations

433
00:25:09,099 --> 00:25:14,589
of the first expression
and the second expression,

434
00:25:14,589 --> 00:25:17,035
or the first expression
and the second one.

435
00:25:17,035 --> 00:25:19,820
So this one is E 0.

436
00:25:19,830 --> 00:25:23,594
And this one is He wants,

437
00:25:23,594 --> 00:25:26,640
you can draw them as trees.

438
00:25:26,640 --> 00:25:30,454
Now, notice, right, all this is,

439
00:25:30,454 --> 00:25:33,185
we call this data
structure a tree,

440
00:25:33,185 --> 00:25:35,000
and we draw it like that.

441
00:25:35,000 --> 00:25:37,759
And you know, so that
what this means is you

442
00:25:37,759 --> 00:25:40,820
should all now do a
head stand, right?

443
00:25:40,820 --> 00:25:41,990
Because you need to
look at them like

444
00:25:41,990 --> 00:25:43,759
that to understand
why it's a tree.

445
00:25:43,759 --> 00:25:46,400
Are trees grow from the
top down rather than

446
00:25:46,400 --> 00:25:50,269
every tree in real life which
grows from the ground up.

447
00:25:50,269 --> 00:25:56,614
Okay. But these are called trees.

448
00:25:56,614 --> 00:25:58,369
And does that visualization from

449
00:25:58,369 --> 00:26:01,270
the tree help people write?

450
00:26:01,270 --> 00:26:03,319
It helps me a lot.

451
00:26:03,319 --> 00:26:05,314
And the important thing is,

452
00:26:05,314 --> 00:26:08,000
you can then see
this one has plus at

453
00:26:08,000 --> 00:26:10,759
its root and times in a sub tree,

454
00:26:10,759 --> 00:26:13,190
this one has times at its root.

455
00:26:13,190 --> 00:26:16,340
And plus in a sub tree,

456
00:26:16,340 --> 00:26:18,720
is that clear to everybody?

457
00:26:19,690 --> 00:26:24,589
Okay? So at this point,

458
00:26:24,589 --> 00:26:26,689
you should understand
at least one example

459
00:26:26,689 --> 00:26:28,100
of how recursion works.

460
00:26:28,100 --> 00:26:29,915
And you might not be sure

461
00:26:29,915 --> 00:26:32,180
that you can always make it work.

462
00:26:32,180 --> 00:26:34,970
But you should have some idea
of what's going on here.

463
00:26:34,970 --> 00:26:37,309
Notice, by the way,
when we do lists,

464
00:26:37,309 --> 00:26:40,834
lists are also, they
can be drawn as a tree,

465
00:26:40,834 --> 00:26:42,725
but it's very lopsided.

466
00:26:42,725 --> 00:26:46,714
So here is the list one.

467
00:26:46,714 --> 00:26:51,095
And then the tail of that
is going to have had too.

468
00:26:51,095 --> 00:26:55,190
The tale of that is going to have

469
00:26:55,190 --> 00:26:59,060
three and then the tail
of that is empty, right?

470
00:26:59,060 --> 00:27:03,080
So this is one cons,

471
00:27:03,080 --> 00:27:10,220
two cons, three
cons, empty, right?

472
00:27:10,220 --> 00:27:14,675
Which we also write
as the list 123.

473
00:27:14,675 --> 00:27:17,435
So Lists also are trees,

474
00:27:17,435 --> 00:27:20,599
but they are very lopsided trees.

475
00:27:20,599 --> 00:27:23,870
So now you see two examples of

476
00:27:23,870 --> 00:27:26,120
a recursive data structure drawn

477
00:27:26,120 --> 00:27:29,584
as a tree, lists and expressions.

478
00:27:29,584 --> 00:27:33,515
Okay? And they must be
lossless, lop-sided.

479
00:27:33,515 --> 00:27:36,080
Whereas these can, right,

480
00:27:36,080 --> 00:27:38,360
you've got complete
freedom as to what goes in

481
00:27:38,360 --> 00:27:41,149
either the left subtree
or the right sub tree.

482
00:27:41,149 --> 00:27:43,250
Because the type
declarations are different.

483
00:27:43,250 --> 00:27:47,960
For lists, we said it's a
cons of an a and a list of a.

484
00:27:47,960 --> 00:27:49,294
So those are different types.

485
00:27:49,294 --> 00:27:52,234
Here. It's add of an x and an x,

486
00:27:52,234 --> 00:27:53,945
they are the same type.

487
00:27:53,945 --> 00:28:00,275
Okay? And then indeed,

488
00:28:00,275 --> 00:28:03,875
if we evaluate the first
of these IO, it gives 11.

489
00:28:03,875 --> 00:28:06,590
But if evaluate the
other one, we get 15.

490
00:28:06,590 --> 00:28:08,150
I've just written
these out as a bunch

491
00:28:08,150 --> 00:28:09,590
of equals conjoined together.

492
00:28:09,590 --> 00:28:11,660
But let's just check, right?

493
00:28:11,660 --> 00:28:16,019
If I, oops, I say ten.

494
00:28:16,360 --> 00:28:23,810
Thanks. If I say test XP,

495
00:28:23,810 --> 00:28:27,090
whoops, test underbar XP.

496
00:28:28,090 --> 00:28:33,450
True, right, so all four of
those statements are true.

497
00:28:35,980 --> 00:28:39,349
And that's all there is to it.

498
00:28:39,349 --> 00:28:41,149
Right? If you want to add,

499
00:28:41,149 --> 00:28:42,859
subtract and divide,

500
00:28:42,859 --> 00:28:46,140
you would now know
what to do, right?

501
00:28:46,570 --> 00:28:49,549
Is that fairly clear to people?

502
00:28:49,549 --> 00:28:51,740
Okay. So that's all
there is to at all

503
00:28:51,740 --> 00:28:53,660
you need to know is a white I

504
00:28:53,660 --> 00:28:55,790
defining a thing whose components

505
00:28:55,790 --> 00:28:57,945
are the same sort of thing.

506
00:28:57,945 --> 00:29:01,030
And that's a recursive
data definition.

507
00:29:01,030 --> 00:29:04,420
And therefore I need a
recursive function definition

508
00:29:04,420 --> 00:29:06,505
to act on that recursive data.

509
00:29:06,505 --> 00:29:08,214
So they go hand in hand.

510
00:29:08,214 --> 00:29:10,104
Whenever you have recursive data,

511
00:29:10,104 --> 00:29:13,404
you should have a recursive
function to act on it.

512
00:29:13,404 --> 00:29:15,619
Okay?

513
00:29:22,290 --> 00:29:28,989
Oops, right, so
there's some examples,

514
00:29:28,989 --> 00:29:31,100
but we've been through that.

515
00:29:32,040 --> 00:29:35,320
Now. We can do Haskell's a bit

516
00:29:35,320 --> 00:29:37,795
flexible so we could also write,

517
00:29:37,795 --> 00:29:40,319
instead of writing the ADD
and the model at the front,

518
00:29:40,319 --> 00:29:43,250
we can write them in
between two things.

519
00:29:43,250 --> 00:29:45,650
Between tactics, because Haskell

520
00:29:45,650 --> 00:29:47,854
allows that as an abbreviation.

521
00:29:47,854 --> 00:29:50,209
If you write E back, tick,

522
00:29:50,209 --> 00:29:53,209
add F, that just
stands for add a,

523
00:29:53,209 --> 00:29:54,950
v and f, right?

524
00:29:54,950 --> 00:29:57,754
Just two ways of
writing the same thing.

525
00:29:57,754 --> 00:29:59,779
So here we've just
written the same

526
00:29:59,779 --> 00:30:01,340
thing in a different way.

527
00:30:01,340 --> 00:30:09,574
And so that's fairly
straightforward.

528
00:30:09,574 --> 00:30:15,934
So behaves same way. And also
we can write symbols index.

529
00:30:15,934 --> 00:30:19,700
So remember, this is
a constructor, right?

530
00:30:19,700 --> 00:30:21,094
Add is a constructor,

531
00:30:21,094 --> 00:30:24,020
so it begins with a
capital letter, right?

532
00:30:24,020 --> 00:30:25,699
And even when it appears in fix,

533
00:30:25,699 --> 00:30:27,170
it begins with a
capital letter, right?

534
00:30:27,170 --> 00:30:29,105
Types begin with capital letters.

535
00:30:29,105 --> 00:30:31,280
Constructors begin
with capital letters.

536
00:30:31,280 --> 00:30:33,545
Function names begin
with small letters.

537
00:30:33,545 --> 00:30:36,409
Variable names begin
with small letters.

538
00:30:36,409 --> 00:30:38,000
And that's by the
way, how you can

539
00:30:38,000 --> 00:30:40,174
tell if you're looking
at something like this,

540
00:30:40,174 --> 00:30:41,659
which thing is the constructor,

541
00:30:41,659 --> 00:30:43,250
in which thing is the variable?

542
00:30:43,250 --> 00:30:45,440
Well, if it's a capital
letter, it's a constructor.

543
00:30:45,440 --> 00:30:47,599
If it's a small letter,
it's a variable.

544
00:30:47,599 --> 00:30:49,219
That's why we have
that convention.

545
00:30:49,219 --> 00:30:51,860
But how do you begin
to assemble with

546
00:30:51,860 --> 00:30:54,590
a capital letter? O dare?

547
00:30:54,590 --> 00:30:58,729
So Haskell has this
very weird convention.

548
00:30:58,729 --> 00:31:04,055
For symbols, the capital
letter is colon.

549
00:31:04,055 --> 00:31:06,335
So if you begin with a colon,

550
00:31:06,335 --> 00:31:09,335
You're a constructor and
otherwise you're not.

551
00:31:09,335 --> 00:31:11,435
And the way you can remember this

552
00:31:11,435 --> 00:31:13,160
is the cons is written as

553
00:31:13,160 --> 00:31:17,075
a colon and Collins
is a constructor.

554
00:31:17,075 --> 00:31:19,250
So if you begin with a colon,

555
00:31:19,250 --> 00:31:20,630
You're a constructor and

556
00:31:20,630 --> 00:31:22,280
otherwise you're not
columns by the way,

557
00:31:22,280 --> 00:31:24,290
to say they know what
cons is short for.

558
00:31:24,290 --> 00:31:27,799
Can you guess constructor, right?

559
00:31:27,799 --> 00:31:30,780
Cons is just short
for constructor.

560
00:31:31,420 --> 00:31:35,839
So now we can declare
this by saying x colon

561
00:31:35,839 --> 00:31:40,549
plus xp and x colon times x.

562
00:31:40,549 --> 00:31:43,564
We write cones before and
after to be symmetric.

563
00:31:43,564 --> 00:31:45,499
That's the colon at the front,

564
00:31:45,499 --> 00:31:48,300
that makes it into a constructor.

565
00:31:48,490 --> 00:31:51,544
And then it looks just
like what we did before.

566
00:31:51,544 --> 00:31:53,645
Everything else is the same.

567
00:31:53,645 --> 00:31:56,135
So is that clear to people?

568
00:31:56,135 --> 00:32:06,589
Question. Yep. What about the Oh,

569
00:32:06,589 --> 00:32:09,274
could you write this one
without parentheses?

570
00:32:09,274 --> 00:32:10,909
No. Cuz it well,

571
00:32:10,909 --> 00:32:12,799
how do you tell it
which one binds

572
00:32:12,799 --> 00:32:14,750
more tightly plus or times?

573
00:32:14,750 --> 00:32:16,175
If you write it
without parentheses,

574
00:32:16,175 --> 00:32:18,320
it will make something
up and do it.

575
00:32:18,320 --> 00:32:22,520
But what I recommend is always
put in the parentheses,

576
00:32:22,520 --> 00:32:25,130
so it's absolutely
clear what's going on.

577
00:32:25,130 --> 00:32:28,069
So good question. Is
there another question?

578
00:32:28,069 --> 00:32:30,199
By the way, the technical name

579
00:32:30,199 --> 00:32:32,434
for that is not order
of application.

580
00:32:32,434 --> 00:32:35,285
The technical name for
that is precedents.

581
00:32:35,285 --> 00:32:38,764
Which of these two operators
binds more tightly?

582
00:32:38,764 --> 00:32:42,359
So the answer for
Haskell is if I write,

583
00:32:46,090 --> 00:32:48,410
if I write one,

584
00:32:48,410 --> 00:32:53,719
sorry if I write yet 2x
plus three times three.

585
00:32:53,719 --> 00:32:58,770
What's Haskell going
to return 11 or 15.

586
00:33:01,090 --> 00:33:06,634
11. So in Haskell times binds
more tightly than plus.

587
00:33:06,634 --> 00:33:15,799
Okay. Okay, so now
we're done, right?

588
00:33:15,799 --> 00:33:17,869
And, and the same thing works.

589
00:33:17,869 --> 00:33:19,445
So now when we
write these things,

590
00:33:19,445 --> 00:33:21,650
we can almost read them, right?

591
00:33:21,650 --> 00:33:23,689
This looks almost like
what's supposed to

592
00:33:23,689 --> 00:33:26,149
be which is two plus
three times three.

593
00:33:26,149 --> 00:33:28,759
And this one looks almost
like what's supposed to be,

594
00:33:28,759 --> 00:33:32,854
which is two plus three in
parentheses times three.

595
00:33:32,854 --> 00:33:37,159
So using symbol
infix notation makes

596
00:33:37,159 --> 00:33:39,259
these things close to

597
00:33:39,259 --> 00:33:42,630
something you can actually
read, which is very helpful.

598
00:33:44,080 --> 00:33:48,410
And what we're actually
learning here is how to

599
00:33:48,410 --> 00:33:51,724
define your own small
programming language

600
00:33:51,724 --> 00:33:53,690
within Haskell.

601
00:33:53,690 --> 00:33:56,629
And that's actually
one of the things that

602
00:33:56,629 --> 00:33:59,599
functional programming
languages are best for,

603
00:33:59,599 --> 00:34:01,640
which is often you want to define

604
00:34:01,640 --> 00:34:03,379
your own small language to

605
00:34:03,379 --> 00:34:06,395
express whatever problem
it is you're working with.

606
00:34:06,395 --> 00:34:09,665
And because you can write
things out in this way,

607
00:34:09,665 --> 00:34:14,225
functional languages
are really good for,

608
00:34:14,225 --> 00:34:17,540
excuse me, functional
languages are really good for

609
00:34:17,540 --> 00:34:21,185
writing down definitions
of other languages.

610
00:34:21,185 --> 00:34:24,150
That's one of the
things they're best at.

611
00:34:24,280 --> 00:34:28,069
A small language for a
particular application.

612
00:34:28,069 --> 00:34:31,760
When word for an application
is a domain of application,

613
00:34:31,760 --> 00:34:35,075
which just means a place
where you're doing stuff.

614
00:34:35,075 --> 00:34:38,510
So programming languages for

615
00:34:38,510 --> 00:34:39,919
special applications are called

616
00:34:39,919 --> 00:34:42,289
domain-specific languages.

617
00:34:42,289 --> 00:34:44,059
And the way I like
to explain this is

618
00:34:44,059 --> 00:34:45,980
that functional languages are

619
00:34:45,980 --> 00:34:47,899
domain-specific languages for

620
00:34:47,899 --> 00:34:51,185
defining domain-specific
languages.

621
00:34:51,185 --> 00:34:54,020
So here we can see it's
pretty easy to come up with

622
00:34:54,020 --> 00:34:56,449
a language to
represent expressions.

623
00:34:56,449 --> 00:34:58,129
Now you wouldn't want
just that because you've

624
00:34:58,129 --> 00:35:00,065
already got expressions
in Haskell.

625
00:35:00,065 --> 00:35:02,180
But for other purposes
that will turn out to

626
00:35:02,180 --> 00:35:05,580
be really convenient idea.

627
00:35:07,050 --> 00:35:11,169
So let's do another example.

628
00:35:11,169 --> 00:35:12,895
Something near and
dear to your heart.

629
00:35:12,895 --> 00:35:15,084
Let's write a Haskell program

630
00:35:15,084 --> 00:35:17,514
that can do your CL homework.

631
00:35:17,514 --> 00:35:19,699
Would you like to do that?

632
00:35:20,760 --> 00:35:23,499
We're going to write a
Haskell program that can do

633
00:35:23,499 --> 00:35:25,975
your CL homework for you.

634
00:35:25,975 --> 00:35:30,469
So we're going to use
exactly the same trick.

635
00:35:30,570 --> 00:35:32,935
Right? We're going to define

636
00:35:32,935 --> 00:35:36,324
propositions and we're going
to have just a few kinds.

637
00:35:36,324 --> 00:35:38,559
It's a variable which must

638
00:35:38,559 --> 00:35:41,184
have a name and the name is
just going to be a string.

639
00:35:41,184 --> 00:35:44,275
Or it's false, or it's true.

640
00:35:44,275 --> 00:35:47,199
I've, I, I'm not
spelled these out

641
00:35:47,199 --> 00:35:50,325
because false and true are
already defined for Booleans.

642
00:35:50,325 --> 00:35:51,799
I need to use something else.

643
00:35:51,799 --> 00:35:53,614
I've just used F and T.

644
00:35:53,614 --> 00:35:56,974
Or it's a not of
another proposition.

645
00:35:56,974 --> 00:36:00,439
Or it's an OR oven of
two other propositions,

646
00:36:00,439 --> 00:36:04,100
or an AND of two
other propositions.

647
00:36:04,100 --> 00:36:06,709
And then we've got two
abbreviations will

648
00:36:06,709 --> 00:36:08,479
use names is just going to be

649
00:36:08,479 --> 00:36:12,619
a list of names and we've
got an environment, right?

650
00:36:12,619 --> 00:36:15,680
Because when you are
given a proposition,

651
00:36:15,680 --> 00:36:17,510
if you want to know if
it's true or false,

652
00:36:17,510 --> 00:36:19,369
you'll have to know
for each variable,

653
00:36:19,369 --> 00:36:22,980
is that variable true or false?

654
00:36:23,860 --> 00:36:28,850
So an environment tells
us for each name,

655
00:36:28,850 --> 00:36:31,475
is it true or is it false?

656
00:36:31,475 --> 00:36:36,409
So now, showing a
proposition is easy, right?

657
00:36:36,409 --> 00:36:38,810
If it's variable x,
just write out x.

658
00:36:38,810 --> 00:36:41,390
If it's f, write out F If it's t

659
00:36:41,390 --> 00:36:43,969
right out t. If
it's not right out

660
00:36:43,969 --> 00:36:49,654
until the if it's an or
right out a vertical bar.

661
00:36:49,654 --> 00:36:51,635
And if it's an and write out

662
00:36:51,635 --> 00:36:54,845
an ampersand and all the
rest of this you can see

663
00:36:54,845 --> 00:36:58,039
looks pretty much
exactly like what we

664
00:36:58,039 --> 00:37:03,539
did for numerical
expressions question.

665
00:37:06,220 --> 00:37:11,075
All right, so I've said
here deriving eq and Ord.

666
00:37:11,075 --> 00:37:20,180
So or just means you can do
less than between things.

667
00:37:20,180 --> 00:37:21,590
So this lets you actually compare

668
00:37:21,590 --> 00:37:24,725
these things to see if
one smaller than another.

669
00:37:24,725 --> 00:37:27,139
But I don't, I can't honestly

670
00:37:27,139 --> 00:37:28,280
remember why stuck that

671
00:37:28,280 --> 00:37:29,719
in there. So don't
worry about it.

672
00:37:29,719 --> 00:37:31,340
Iq means we can
compare them to see

673
00:37:31,340 --> 00:37:33,199
if they're the same,
which is useful.

674
00:37:33,199 --> 00:37:43,069
Yep. You can use

675
00:37:43,069 --> 00:37:44,449
less than or equal four implies,

676
00:37:44,449 --> 00:37:45,620
but I'm not doing that here,

677
00:37:45,620 --> 00:37:50,369
so don't worry about that yet.

678
00:37:57,310 --> 00:38:00,170
Yes. Of the particular way 4D

679
00:38:00,170 --> 00:38:02,060
works is it looks at
the order you gave me.

680
00:38:02,060 --> 00:38:04,399
So because I wrote f before t,

681
00:38:04,399 --> 00:38:07,249
F will be less than t and
t will be less than not.

682
00:38:07,249 --> 00:38:08,959
And not will be
less than and, or,

683
00:38:08,959 --> 00:38:10,670
but honestly,

684
00:38:10,670 --> 00:38:12,229
I don't want you to find
less than right now,

685
00:38:12,229 --> 00:38:14,180
so let's not worry
about that one.

686
00:38:14,180 --> 00:38:18,965
Okay? So this just turns
a prop into a string,

687
00:38:18,965 --> 00:38:21,409
very similar to what
we showed before.

688
00:38:21,409 --> 00:38:23,719
This. Now here's
something useful.

689
00:38:23,719 --> 00:38:25,909
What are all the
names mentioned in

690
00:38:25,909 --> 00:38:29,855
a given proposition will
want to make use of that.

691
00:38:29,855 --> 00:38:32,720
So if it's a variable,

692
00:38:32,720 --> 00:38:35,899
x obviously mentions the
name X, so that's easy.

693
00:38:35,899 --> 00:38:38,945
That's f. There are no
names in it. That's easy.

694
00:38:38,945 --> 00:38:41,419
T, there are no names
in it. That's easy.

695
00:38:41,419 --> 00:38:43,640
If it's not p, it will be

696
00:38:43,640 --> 00:38:46,355
whatever variables
appear in p, right?

697
00:38:46,355 --> 00:38:48,304
So it'll be the names of p,

698
00:38:48,304 --> 00:38:50,690
f is p or q.

699
00:38:50,690 --> 00:38:53,704
Then we'll take all the
names and P and add,

700
00:38:53,704 --> 00:38:56,195
append to the list
all the names and q.

701
00:38:56,195 --> 00:39:00,515
Why it might be something
like var x or Var aX.

702
00:39:00,515 --> 00:39:03,409
So that would give the
list that has x in

703
00:39:03,409 --> 00:39:06,199
it twice. And so we apply nub.

704
00:39:06,199 --> 00:39:08,670
Does anybody know what NEP does?

705
00:39:10,960 --> 00:39:14,150
Nub removes repeated
elements from a list.

706
00:39:14,150 --> 00:39:18,299
So I think we can test
this out. Let's try it.

707
00:39:30,900 --> 00:39:35,184
So here we've got
some propositions.

708
00:39:35,184 --> 00:39:38,709
So this is a and B,

709
00:39:38,709 --> 00:39:43,749
or not var a, var b.

710
00:39:43,749 --> 00:39:47,905
And this one is a and naught a.

711
00:39:47,905 --> 00:39:51,354
And here's an
environment which says,

712
00:39:51,354 --> 00:39:52,584
right, we'll look at the summit.

713
00:39:52,584 --> 00:39:56,304
Let's see what happens when
a is false and B is false.

714
00:39:56,304 --> 00:39:59,620
So if we show prop p 0, right?

715
00:39:59,620 --> 00:40:02,215
Does everybody see
why we get that?

716
00:40:02,215 --> 00:40:06,075
And then if we do
show prop of P1,

717
00:40:06,075 --> 00:40:08,539
does everybody see
why we get that?

718
00:40:08,539 --> 00:40:14,945
And then the names
of P are not ABAB,

719
00:40:14,945 --> 00:40:16,655
which is, you might expect,

720
00:40:16,655 --> 00:40:18,710
but just a and B because the knob

721
00:40:18,710 --> 00:40:20,929
gets rid of duplicates, right?

722
00:40:20,929 --> 00:40:27,289
Cuz if we say, actually,

723
00:40:27,289 --> 00:40:32,640
let's write, if I
get rid of the nub,

724
00:40:34,210 --> 00:40:37,550
I get rid of the two
instance of knob.

725
00:40:37,550 --> 00:40:45,034
And then I take
right, which is that.

726
00:40:45,034 --> 00:40:47,840
And I noticed that it
gives me that because

727
00:40:47,840 --> 00:40:50,914
I've said deriving show,

728
00:40:50,914 --> 00:40:52,219
I didn't have that
and the other side,

729
00:40:52,219 --> 00:40:53,389
tell tell you what
we're gonna do here.

730
00:40:53,389 --> 00:40:55,715
We get River or we
don't care about 4D.

731
00:40:55,715 --> 00:40:58,115
We're just going
to deriving show.

732
00:40:58,115 --> 00:40:59,750
We check that didn't
break anything

733
00:40:59,750 --> 00:41:01,355
now that didn't break anything.

734
00:41:01,355 --> 00:41:04,115
So that means I was
never using Ord.

735
00:41:04,115 --> 00:41:07,849
So show is the built in Haskell

736
00:41:07,849 --> 00:41:09,319
show function which
prints out something

737
00:41:09,319 --> 00:41:11,495
exactly the same
way you type it in.

738
00:41:11,495 --> 00:41:14,105
But we've also defined show prop.

739
00:41:14,105 --> 00:41:19,909
So show prop of P is now
going to do it as a string,

740
00:41:19,909 --> 00:41:21,785
which is much more readable.

741
00:41:21,785 --> 00:41:24,844
And now if I do names of
PCR, I got rid of the nub.

742
00:41:24,844 --> 00:41:26,940
So what am I going to get?

743
00:41:27,040 --> 00:41:31,200
I will get a b, a b.

744
00:41:31,510 --> 00:41:34,654
But notice if I take the nub,

745
00:41:34,654 --> 00:41:37,879
well, so if I take the nub of
AB, what am I going to get?

746
00:41:37,879 --> 00:41:40,235
Right? There are no duplicates.

747
00:41:40,235 --> 00:41:44,510
If I take the nub of a, b,

748
00:41:44,510 --> 00:41:53,129
a, b, then it gives me AB, okay?

749
00:41:54,280 --> 00:41:59,239
Or if I take the nub of a,

750
00:41:59,239 --> 00:42:06,534
b, b, a, what do we get?

751
00:42:06,534 --> 00:42:10,285
Will also get AB. So it
goes from the beginning.

752
00:42:10,285 --> 00:42:14,065
So the nub of ABA is ab.

753
00:42:14,065 --> 00:42:17,020
So if you want a more
core rock group,

754
00:42:17,020 --> 00:42:19,130
you should call it ab.

755
00:42:23,820 --> 00:42:27,049
Let's put the nubs back.

756
00:42:38,670 --> 00:42:42,310
And so now if we do names P 0,

757
00:42:42,310 --> 00:42:43,960
right, we'll just get a and b.

758
00:42:43,960 --> 00:42:46,709
And what do I, what will
we get if I do names P1?

759
00:42:46,709 --> 00:42:52,010
So p1 is very and not var a.

760
00:42:52,010 --> 00:42:59,630
And if I do show
prop P1, I get that.

761
00:42:59,630 --> 00:43:02,969
And if I do names
P1, what will I get?

762
00:43:04,900 --> 00:43:08,249
Don't all answer at once.

763
00:43:08,470 --> 00:43:12,154
What will I get if I do names p1,

764
00:43:12,154 --> 00:43:19,050
a, meaning the list
containing the string a.

765
00:43:19,300 --> 00:43:23,969
Okay? So just one
name appears there.

766
00:43:25,600 --> 00:43:29,580
Okay, everybody learn
how names works.

767
00:43:30,210 --> 00:43:33,940
And then the
interesting thing is I

768
00:43:33,940 --> 00:43:37,240
can evaluate a proposition,

769
00:43:37,240 --> 00:43:38,349
but to evaluate it,

770
00:43:38,349 --> 00:43:43,015
I need to know what to
do for each variable.

771
00:43:43,015 --> 00:43:45,699
So the key thing is
if it's a variable,

772
00:43:45,699 --> 00:43:47,739
I look it up in the environments.

773
00:43:47,739 --> 00:43:49,720
And now E ranges not over

774
00:43:49,720 --> 00:43:52,495
expressions but
over environments.

775
00:43:52,495 --> 00:43:57,009
And an environment is
a list of AB pairs.

776
00:43:57,009 --> 00:43:59,469
I give it an a, that's
going to return a b.

777
00:43:59,469 --> 00:44:00,534
How is it going to do that?

778
00:44:00,534 --> 00:44:02,379
It just looks down the list

779
00:44:02,379 --> 00:44:04,600
until it finds one that matches.

780
00:44:04,600 --> 00:44:07,255
So here I've done that
with a comprehension.

781
00:44:07,255 --> 00:44:09,505
So we say form the XP.

782
00:44:09,505 --> 00:44:12,420
Look, look at everything
in this list.

783
00:44:12,420 --> 00:44:14,149
This list of AB pairs.

784
00:44:14,149 --> 00:44:16,114
I'll call it x, y's.

785
00:44:16,114 --> 00:44:19,535
So each thing it, it
is an x prime y pair.

786
00:44:19,535 --> 00:44:20,900
I've already been given acts.

787
00:44:20,900 --> 00:44:22,265
That's what I'm looking for.

788
00:44:22,265 --> 00:44:26,060
So I filter out, I just
have the X Y pairs,

789
00:44:26,060 --> 00:44:28,400
where x and x prime are the same.

790
00:44:28,400 --> 00:44:30,470
I just return the y's

791
00:44:30,470 --> 00:44:33,035
and there really should
be exactly one of them.

792
00:44:33,035 --> 00:44:35,419
So I've got this
function v, right?

793
00:44:35,419 --> 00:44:36,500
So this would be a list of

794
00:44:36,500 --> 00:44:39,409
B. I say note that should
be a list of length one.

795
00:44:39,409 --> 00:44:42,720
Just return that one
thing in the list.

796
00:44:43,210 --> 00:44:48,630
So if I do, let's try this.

797
00:44:53,890 --> 00:45:05,165
So let's let down
here, right? N 0.

798
00:45:05,165 --> 00:45:10,369
N 0 is a list that pairs a
with false and b with false.

799
00:45:10,369 --> 00:45:12,394
And then if I say,

800
00:45:12,394 --> 00:45:18,229
look up a in n 0,

801
00:45:18,229 --> 00:45:20,495
what is it going to return?

802
00:45:20,495 --> 00:45:26,549
False? That's all.

803
00:45:27,040 --> 00:45:30,300
That's very odd.

804
00:45:40,360 --> 00:45:47,819
Yeah, that should work for
that again. Thank you.

805
00:45:48,220 --> 00:45:52,055
Right. It returns
false. Thank you.

806
00:45:52,055 --> 00:45:53,689
Why didn't give me a
type error for that?

807
00:45:53,689 --> 00:45:57,149
I don't know. But there we go.

808
00:45:58,270 --> 00:46:06,209
And if I look up b,
what am I going to get?

809
00:46:07,390 --> 00:46:13,140
Not all at once. Also false.

810
00:46:13,330 --> 00:46:17,579
F, I look up and see
what am I going to get?

811
00:46:22,140 --> 00:46:26,394
It says there is
no c here, right?

812
00:46:26,394 --> 00:46:31,344
Non-exhaustive patterns
in function v. V what?

813
00:46:31,344 --> 00:46:34,669
Oh, wait, these the name
of the function, okay.

814
00:46:36,270 --> 00:46:39,219
Right, so D has been
given here a list of

815
00:46:39,219 --> 00:46:42,290
length 0 and then it gets upset.

816
00:46:43,500 --> 00:46:49,520
So now we can use lookup
to evaluate something.

817
00:46:54,750 --> 00:47:02,539
So if I look up,

818
00:47:02,680 --> 00:47:07,309
right, if I evaluate p 0 and n 0,

819
00:47:07,309 --> 00:47:09,360
what am I going to get?

820
00:47:09,520 --> 00:47:13,039
Where we're going to
get? First, we're

821
00:47:13,039 --> 00:47:15,124
gonna evaluate this
sub term a and

822
00:47:15,124 --> 00:47:18,229
b. Ands that means

823
00:47:18,229 --> 00:47:21,619
first we'll evaluate a and
that will evaluate t2.

824
00:47:21,619 --> 00:47:26,660
We look it up.
False. Now evaluate

825
00:47:26,660 --> 00:47:29,090
b and we look it up and
that gives us false and

826
00:47:29,090 --> 00:47:33,440
false and false is false.

827
00:47:33,440 --> 00:47:35,555
So this gives us false.

828
00:47:35,555 --> 00:47:36,920
And now we'll do this one.

829
00:47:36,920 --> 00:47:38,705
So if we look up our a again,

830
00:47:38,705 --> 00:47:43,744
that is not a false is.

831
00:47:43,744 --> 00:47:46,879
And here we do. We look
up b that's false,

832
00:47:46,879 --> 00:47:50,060
not false is and we,

833
00:47:50,060 --> 00:47:52,984
and true and true
together and we get,

834
00:47:52,984 --> 00:47:55,205
and now we've got false here,

835
00:47:55,205 --> 00:48:01,190
true here false or true
is false or true is true.

836
00:48:01,190 --> 00:48:03,690
So if we try it,

837
00:48:06,400 --> 00:48:13,040
email and 0, p 0,

838
00:48:13,040 --> 00:48:15,110
yes, we get true.

839
00:48:15,110 --> 00:48:16,820
Okay, it's the same thing.

840
00:48:16,820 --> 00:48:20,910
It's just recursively looking
it up for each sub term.

841
00:48:21,550 --> 00:48:24,019
Okay? And also you
could figure out

842
00:48:24,019 --> 00:48:26,300
how to draw these as trees.

843
00:48:26,300 --> 00:48:28,040
The way we drew these,

844
00:48:28,040 --> 00:48:32,405
these as trees, if you want to.

845
00:48:32,405 --> 00:48:36,064
So the last trick
here, we're at time.

846
00:48:36,064 --> 00:48:37,745
But the last trick,

847
00:48:37,745 --> 00:48:40,279
I will not show you in detail
because we're at time,

848
00:48:40,279 --> 00:48:43,160
but you'll get more time
to look at this later.

849
00:48:43,160 --> 00:48:44,569
You can actually generate a list

850
00:48:44,569 --> 00:48:46,580
of all possible environments.

851
00:48:46,580 --> 00:48:48,110
And then you can ask, is there

852
00:48:48,110 --> 00:48:51,395
any environment where
this returns true?

853
00:48:51,395 --> 00:48:53,764
And that's called satisfiability.

854
00:48:53,764 --> 00:48:56,225
Or you can say in
every environment,

855
00:48:56,225 --> 00:48:57,725
does this return true?

856
00:48:57,725 --> 00:48:59,195
That's tautology.

857
00:48:59,195 --> 00:49:01,715
So we'll look at more
detail how to do that.

858
00:49:01,715 --> 00:49:04,040
But you've begun to
see how you can use

859
00:49:04,040 --> 00:49:05,269
these techniques to do

860
00:49:05,269 --> 00:49:08,130
your own homework.
Thank you very much.
