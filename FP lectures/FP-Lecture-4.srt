1
00:00:00,170 --> 00:00:10,480
Good morning. Are
there any questions?

2
00:00:12,410 --> 00:00:15,120
No questions.

3
00:00:15,120 --> 00:00:18,150
Are people happy, unhappy?

4
00:00:18,150 --> 00:00:22,210
Who feels the FP part of
the course is going okay?

5
00:00:22,690 --> 00:00:27,290
Who feels drowned and
lost in the epi part?

6
00:00:27,290 --> 00:00:31,625
Okay? Who kills the
CL parts going okay.

7
00:00:31,625 --> 00:00:35,644
Who feels drowned and
lost in the CL part?

8
00:00:35,644 --> 00:00:37,820
Okay, I'm doing
better than Michael.

9
00:00:37,820 --> 00:00:42,709
Yea. Don't worry if
you're feeling lost,

10
00:00:42,709 --> 00:00:44,494
you can see that there are,

11
00:00:44,494 --> 00:00:47,525
there's always some proportion
of people that feel lost.

12
00:00:47,525 --> 00:00:48,935
And that's fine.

13
00:00:48,935 --> 00:00:51,589
What is important if you
feel loss is to take

14
00:00:51,589 --> 00:00:55,039
advantage of all the different
things available to you.

15
00:00:55,039 --> 00:00:57,455
Go to the labs, go to in Pals,

16
00:00:57,455 --> 00:00:58,849
talk to some of the people who

17
00:00:58,849 --> 00:01:00,260
raised their hand when I said,

18
00:01:00,260 --> 00:01:02,150
are you feeling okay?

19
00:01:02,150 --> 00:01:06,484
Talk to your friends and
preparing, go to tutorial.

20
00:01:06,484 --> 00:01:09,050
All of these things
are available to

21
00:01:09,050 --> 00:01:11,630
you and make sure to
take advantage of them.

22
00:01:11,630 --> 00:01:14,149
It's fine to feel a bit lost.

23
00:01:14,149 --> 00:01:17,990
Everybody at some
point should feel

24
00:01:17,990 --> 00:01:19,790
confused and that they don't know

25
00:01:19,790 --> 00:01:21,800
how to do something, right?

26
00:01:21,800 --> 00:01:24,679
That's actually a good thing.

27
00:01:24,679 --> 00:01:26,090
Because if you feel that you

28
00:01:26,090 --> 00:01:27,964
don't know how to do something,

29
00:01:27,964 --> 00:01:29,840
then you can find
out how to do it.

30
00:01:29,840 --> 00:01:32,630
And that's called learning.

31
00:01:32,630 --> 00:01:34,310
I remember back when I was in

32
00:01:34,310 --> 00:01:36,874
high school that I
was clever enough.

33
00:01:36,874 --> 00:01:38,329
So the first time I really got

34
00:01:38,329 --> 00:01:39,769
stuck on something
was in high school.

35
00:01:39,769 --> 00:01:42,620
I remember sitting in
my bedroom swearing at

36
00:01:42,620 --> 00:01:44,210
the wall because I
couldn't follow what was

37
00:01:44,210 --> 00:01:46,999
going on in the
chemistry textbook.

38
00:01:46,999 --> 00:01:50,270
But that was the
beginning of learning.

39
00:01:50,270 --> 00:01:51,920
So don't worry if

40
00:01:51,920 --> 00:01:54,110
there's something that
you don't understand,

41
00:01:54,110 --> 00:01:57,199
but don't give up, right?

42
00:01:57,199 --> 00:02:01,444
That's the point at which
then learning can take place.

43
00:02:01,444 --> 00:02:05,610
Ok. Any questions about that?

44
00:02:06,850 --> 00:02:11,810
Ok. I was expecting
somebody to say,

45
00:02:11,810 --> 00:02:13,669
Well, were you Philip?

46
00:02:13,669 --> 00:02:17,249
He wants to do that.
So I was here.

47
00:02:17,350 --> 00:02:20,479
So I bought back the t-shirt.

48
00:02:20,479 --> 00:02:24,769
So this was the Purdue
Programming Language Center.

49
00:02:24,769 --> 00:02:26,554
They didn't opening.

50
00:02:26,554 --> 00:02:28,355
I think I put up the web page.

51
00:02:28,355 --> 00:02:38,370
Let's see. Oh, there it is.

52
00:02:41,710 --> 00:02:44,749
The Purdue Programming
Language Center,

53
00:02:44,749 --> 00:02:49,490
or purple had their
opening celebration

54
00:02:49,490 --> 00:02:52,444
and then they had a bunch
of keynote speakers.

55
00:02:52,444 --> 00:02:54,065
And I was one of them.

56
00:02:54,065 --> 00:02:57,239
See if you can guess
which one is me.

57
00:03:02,170 --> 00:03:04,519
This guy's from Facebook.

58
00:03:04,519 --> 00:03:06,109
He said lots of interesting PL,

59
00:03:06,109 --> 00:03:08,000
stuff in functional programming.

60
00:03:08,000 --> 00:03:10,280
It's named Eric
Meyer and now he's

61
00:03:10,280 --> 00:03:14,149
doing guess what, deep learning.

62
00:03:14,149 --> 00:03:18,260
So AI is taking over everywhere.

63
00:03:18,260 --> 00:03:19,894
This guy's been Zorn,

64
00:03:19,894 --> 00:03:21,949
he works at Microsoft.

65
00:03:21,949 --> 00:03:24,380
And he gave a really
interesting talk

66
00:03:24,380 --> 00:03:25,640
because he was pointing out that

67
00:03:25,640 --> 00:03:27,679
it's not just programming

68
00:03:27,679 --> 00:03:29,269
that's important, but
dealing with data.

69
00:03:29,269 --> 00:03:31,820
So for instance, they
did some work looking at

70
00:03:31,820 --> 00:03:35,494
Excel spreadsheets and
just saying, okay,

71
00:03:35,494 --> 00:03:37,280
it is the same formula and all

72
00:03:37,280 --> 00:03:39,080
the cells where one cell that has

73
00:03:39,080 --> 00:03:40,700
a different formula where you

74
00:03:40,700 --> 00:03:42,830
wouldn't expect it
and highlighting it.

75
00:03:42,830 --> 00:03:44,989
And then they use that tool.

76
00:03:44,989 --> 00:03:47,900
There's a very famous paper that

77
00:03:47,900 --> 00:03:51,050
basically was used to
justify austerity here.

78
00:03:51,050 --> 00:03:52,100
And in the US saying, well,

79
00:03:52,100 --> 00:03:53,479
if you spend too much,

80
00:03:53,479 --> 00:03:55,384
it's very bad for the economy.

81
00:03:55,384 --> 00:03:57,500
And it turns out that the way
they derive that was from

82
00:03:57,500 --> 00:03:59,120
a spreadsheet and it turns

83
00:03:59,120 --> 00:04:01,190
out there was a bug
in the spreadsheet.

84
00:04:01,190 --> 00:04:02,540
So they didn't count some of

85
00:04:02,540 --> 00:04:05,060
the data that was discovered
later that if you

86
00:04:05,060 --> 00:04:06,710
counted all the data there

87
00:04:06,710 --> 00:04:09,485
conclusions were
completely unjustified.

88
00:04:09,485 --> 00:04:12,020
So this particular justification

89
00:04:12,020 --> 00:04:13,310
for austerity at least was

90
00:04:13,310 --> 00:04:17,360
completely wrong due to an
error in a spreadsheet.

91
00:04:17,360 --> 00:04:19,909
So Eris and spreadsheets
can be significant.

92
00:04:19,909 --> 00:04:21,680
And so they were trying
to figure out, okay,

93
00:04:21,680 --> 00:04:23,315
how would you notice

94
00:04:23,315 --> 00:04:24,829
if there was an error
in a spreadsheet?

95
00:04:24,829 --> 00:04:27,344
So that's an interesting
thing to look at.

96
00:04:27,344 --> 00:04:30,550
And this has definitely work.

97
00:04:30,550 --> 00:04:34,820
She's looking at making
Haskell even more complicated.

98
00:04:34,890 --> 00:04:38,140
And this is Amal Ahmed.

99
00:04:38,140 --> 00:04:41,694
She's a professor at
Northeastern now.

100
00:04:41,694 --> 00:04:46,270
And she's looking at how you
go about proving compilers,

101
00:04:46,270 --> 00:04:48,430
correct when you're doing
independent compilation.

102
00:04:48,430 --> 00:04:50,079
So we've got about 30 years of

103
00:04:50,079 --> 00:04:52,000
history now proving compilers,

104
00:04:52,000 --> 00:04:54,099
correct, but we still don't
know how to provoke you.

105
00:04:54,099 --> 00:04:55,720
Compile this bit and then compile

106
00:04:55,720 --> 00:04:57,550
this bit and then
put them together.

107
00:04:57,550 --> 00:04:59,395
How do you show that
that is correct.

108
00:04:59,395 --> 00:05:02,649
So she's looking at how would
you go about formalizing

109
00:05:02,649 --> 00:05:08,720
that and couldn't
let it works on.

110
00:05:09,070 --> 00:05:11,900
I'll just go through
all that. Why not?

111
00:05:11,900 --> 00:05:17,060
Cooler is at Stanford
and he was in hardware,

112
00:05:17,060 --> 00:05:19,520
but then he got into
programming languages.

113
00:05:19,520 --> 00:05:22,550
Because you need good
programming languages to get

114
00:05:22,550 --> 00:05:24,439
a sufficiently parallel program

115
00:05:24,439 --> 00:05:26,120
that it runs well
on the hardware.

116
00:05:26,120 --> 00:05:28,745
So he's looking at
very high performance.

117
00:05:28,745 --> 00:05:32,330
So basically what my key
lessons in this class is,

118
00:05:32,330 --> 00:05:34,219
don't do what he does.

119
00:05:34,219 --> 00:05:36,770
In that sometimes
really high performance

120
00:05:36,770 --> 00:05:38,255
is quite important.

121
00:05:38,255 --> 00:05:40,024
So in that sense, what he does

122
00:05:40,024 --> 00:05:42,440
is absolutely the
right thing to do.

123
00:05:42,440 --> 00:05:45,919
But many people in
computing tend to get

124
00:05:45,919 --> 00:05:47,870
distracted because performance is

125
00:05:47,870 --> 00:05:49,835
something you can
stick a number on.

126
00:05:49,835 --> 00:05:55,415
My, my program runs in 0.1
microsecond or whatever.

127
00:05:55,415 --> 00:05:57,244
So you can time it and say,

128
00:05:57,244 --> 00:05:58,670
oh look how fast it's going.

129
00:05:58,670 --> 00:06:01,805
And then people tend
to focus on that.

130
00:06:01,805 --> 00:06:06,095
But in fact, that's the
least important thing.

131
00:06:06,095 --> 00:06:07,970
It's the least important thing

132
00:06:07,970 --> 00:06:10,310
because computers have
been getting faster and

133
00:06:10,310 --> 00:06:13,759
faster and faster ever
since they started

134
00:06:13,759 --> 00:06:17,869
building them in the
mid 19 hundreds, right?

135
00:06:17,869 --> 00:06:20,060
So that, you know.

136
00:06:20,060 --> 00:06:23,540
So this guy bends or went

137
00:06:23,540 --> 00:06:25,160
through the history of

138
00:06:25,160 --> 00:06:28,145
computing and he showed when
a supercomputer was like.

139
00:06:28,145 --> 00:06:32,449
1980. And then he showed
an Xbox currently.

140
00:06:32,449 --> 00:06:34,205
And an Xbox currently has

141
00:06:34,205 --> 00:06:39,439
about the same power as a
supercomputer from 1980.

142
00:06:39,439 --> 00:06:41,840
Now supercomputer that you
know, it's a Siri recipient.

143
00:06:41,840 --> 00:06:43,069
Can we got a whole room full of

144
00:06:43,069 --> 00:06:45,544
computers all as
fast as possible?

145
00:06:45,544 --> 00:06:47,360
The number floating
point operations

146
00:06:47,360 --> 00:06:48,740
per second they can do is

147
00:06:48,740 --> 00:06:52,475
comparable to what a
single xbox can do now.

148
00:06:52,475 --> 00:06:54,620
So computers are getting much,

149
00:06:54,620 --> 00:06:58,909
much faster and they
have lots of power.

150
00:06:58,909 --> 00:07:01,444
So if you can spend

151
00:07:01,444 --> 00:07:05,045
a year of hard work programming

152
00:07:05,045 --> 00:07:07,700
to make your program
run twice as fast.

153
00:07:07,700 --> 00:07:12,859
Is that a good use of
your time? Probably not.

154
00:07:12,859 --> 00:07:15,020
But the most important thing to

155
00:07:15,020 --> 00:07:17,959
do with your computer
program is to

156
00:07:17,959 --> 00:07:23,195
make it easy to read
and easy to modify.

157
00:07:23,195 --> 00:07:25,654
If you look at

158
00:07:25,654 --> 00:07:29,615
what all the money is
spent on with software,

159
00:07:29,615 --> 00:07:32,989
it is not on writing,
the software,

160
00:07:32,989 --> 00:07:37,249
is on modifying the software
after it's been written.

161
00:07:37,249 --> 00:07:40,890
This is called maintenance.

162
00:07:40,930 --> 00:07:44,870
So we tend to focus
on writing programs,

163
00:07:44,870 --> 00:07:47,300
but it's actually maintenance.

164
00:07:47,300 --> 00:07:49,850
That's the most important thing.

165
00:07:49,850 --> 00:07:53,090
So the most important thing
is to write your program in

166
00:07:53,090 --> 00:07:56,749
a clear way so that other
people can maintain it.

167
00:07:56,749 --> 00:07:58,730
After you've done
writing it and you've

168
00:07:58,730 --> 00:08:01,490
moved on to your next
company or whatever.

169
00:08:01,490 --> 00:08:04,880
And it turns out there's not
a number for that, right?

170
00:08:04,880 --> 00:08:05,899
Speed is a number,

171
00:08:05,899 --> 00:08:07,685
so it's really easy to measure.

172
00:08:07,685 --> 00:08:09,379
But clarity, people have tried to

173
00:08:09,379 --> 00:08:11,135
come up with numbers for clarity.

174
00:08:11,135 --> 00:08:12,380
But right, there's nothing that

175
00:08:12,380 --> 00:08:13,685
works as well as just saying

176
00:08:13,685 --> 00:08:17,390
my program ran in 1
tenth of a microsecond.

177
00:08:17,390 --> 00:08:20,749
So people tend to ignore clarity.

178
00:08:20,749 --> 00:08:23,015
But that's the important thing.

179
00:08:23,015 --> 00:08:24,919
You know exactly how
important it is.

180
00:08:24,919 --> 00:08:27,095
What am I going to do right now?

181
00:08:27,095 --> 00:08:29,790
Jump up and down.

182
00:08:31,060 --> 00:08:36,364
Maintenance is more important
than raw performance.

183
00:08:36,364 --> 00:08:40,249
Clarity is more
important than speed.

184
00:08:40,249 --> 00:08:42,620
And so you'll see me
spending a lot of

185
00:08:42,620 --> 00:08:45,409
time talking about
how to make programs.

186
00:08:45,409 --> 00:08:48,140
Clare. And I will
occasionally talk about

187
00:08:48,140 --> 00:08:51,274
what makes Program slow and
how to make them faster.

188
00:08:51,274 --> 00:08:53,509
It's not something
that we ignore,

189
00:08:53,509 --> 00:08:56,854
but it's not the first thing.

190
00:08:56,854 --> 00:09:02,375
And indeed dealing with speed
too soon is a real problem.

191
00:09:02,375 --> 00:09:06,230
Premature optimization
is the root of all evil.

192
00:09:06,230 --> 00:09:10,460
I found two different
famous computer scientists

193
00:09:10,460 --> 00:09:12,439
who are attributed
with that quote and,

194
00:09:12,439 --> 00:09:14,029
uh, and I quite believe it.

195
00:09:14,029 --> 00:09:16,309
So that's why I'm jumping
up and down of eyes.

196
00:09:16,309 --> 00:09:17,599
The most important thing is

197
00:09:17,599 --> 00:09:19,850
writing your program
in a clear way.

198
00:09:19,850 --> 00:09:23,510
And then finally, this
is push me, Cole.

199
00:09:23,510 --> 00:09:25,249
And he worked for Deep Mind.

200
00:09:25,249 --> 00:09:27,709
And he was talking
about all the ways in

201
00:09:27,709 --> 00:09:30,679
which AI current
systems currently fail.

202
00:09:30,679 --> 00:09:33,619
So AI systems are really
amazing right there much,

203
00:09:33,619 --> 00:09:36,889
much better than when I
first got into the field.

204
00:09:36,889 --> 00:09:40,010
Mainly because computers
have gotten so much faster.

205
00:09:40,010 --> 00:09:42,440
So you can use various
brute force techniques

206
00:09:42,440 --> 00:09:44,674
and they worked
surprisingly well.

207
00:09:44,674 --> 00:09:47,810
So now we can simulate

208
00:09:47,810 --> 00:09:51,365
millions and millions of
neurons and just see what.

209
00:09:51,365 --> 00:09:54,170
Sorry, not there cold neurons,

210
00:09:54,170 --> 00:09:56,450
but they're a very
simplified model of

211
00:09:56,450 --> 00:09:59,344
the neurons in the human head.

212
00:09:59,344 --> 00:10:00,935
But you can use neuro

213
00:10:00,935 --> 00:10:03,319
simplified neurons to do

214
00:10:03,319 --> 00:10:04,459
really amazing things with what

215
00:10:04,459 --> 00:10:05,539
are called neural networks.

216
00:10:05,539 --> 00:10:06,590
And so typically, right,

217
00:10:06,590 --> 00:10:09,470
you can just train it on
lots of, lots of images.

218
00:10:09,470 --> 00:10:11,014
And then you show it an image.

219
00:10:11,014 --> 00:10:12,229
And it will say that's a cat

220
00:10:12,229 --> 00:10:13,310
and you go, well that's right,

221
00:10:13,310 --> 00:10:14,390
it was a cat and you shoot

222
00:10:14,390 --> 00:10:16,669
another image and says
that's a dot and you say,

223
00:10:16,669 --> 00:10:18,440
wow, that's right, it was a dog.

224
00:10:18,440 --> 00:10:20,270
And then you should,
another image of

225
00:10:20,270 --> 00:10:22,699
the cat with three pixels change,

226
00:10:22,699 --> 00:10:24,649
so it looks identical to you.

227
00:10:24,649 --> 00:10:27,780
And the program says
that's attractor.

228
00:10:28,030 --> 00:10:30,769
And this is an issue

229
00:10:30,769 --> 00:10:32,479
that they don't know
how to tackle yet.

230
00:10:32,479 --> 00:10:34,279
So he was talking
about things that

231
00:10:34,279 --> 00:10:36,724
might be done to tackle
that kind of issue.

232
00:10:36,724 --> 00:10:39,620
But AI is incredibly
powerful, right?

233
00:10:39,620 --> 00:10:41,044
People are using
it more and more,

234
00:10:41,044 --> 00:10:44,839
but it's also in many
ways incredibly weak in

235
00:10:44,839 --> 00:10:46,490
that you can't get any guarantees

236
00:10:46,490 --> 00:10:48,890
about how well or badly
it's going to work.

237
00:10:48,890 --> 00:10:52,250
And these are problems
that need to be solved.

238
00:10:52,250 --> 00:10:55,100
These are the
problems that you are

239
00:10:55,100 --> 00:10:58,529
going to need to
solve in your career.

240
00:10:59,110 --> 00:11:01,924
Okay, so that was
the purple thing.

241
00:11:01,924 --> 00:11:03,995
And then the I, I made
a little slideshow.

242
00:11:03,995 --> 00:11:05,960
What's in my little slideshow?

243
00:11:05,960 --> 00:11:09,419
Should get the little
slideshow of my trip.

244
00:11:10,750 --> 00:11:15,420
Yes. Yes, this little
slideshow of my trip.

245
00:11:15,460 --> 00:11:19,684
So the first thing he
does write my began,

246
00:11:19,684 --> 00:11:21,589
I showed you all the sponsors for

247
00:11:21,589 --> 00:11:24,049
the International Conference
on functional programming.

248
00:11:24,049 --> 00:11:26,735
You can see they're
very similar sponsors.

249
00:11:26,735 --> 00:11:29,119
For this session at

250
00:11:29,119 --> 00:11:32,030
Purdue where they were
opening their new labs.

251
00:11:32,030 --> 00:11:34,369
You've got Facebook
and Microsoft.

252
00:11:34,369 --> 00:11:36,109
And some of these
I don't recognize.

253
00:11:36,109 --> 00:11:38,930
And then this is the
National Science Foundation,

254
00:11:38,930 --> 00:11:41,105
which funds a lot of
research in the US.

255
00:11:41,105 --> 00:11:42,619
And this is the Defense

256
00:11:42,619 --> 00:11:44,615
Advanced Research
Projects Agency,

257
00:11:44,615 --> 00:11:47,449
which funds a loft
projects in the US.

258
00:11:47,449 --> 00:11:49,700
In fact, what we now call

259
00:11:49,700 --> 00:11:51,769
the internet used
to be called the

260
00:11:51,769 --> 00:11:54,470
arpanet because what was

261
00:11:54,470 --> 00:11:57,710
then called arpa did
the original funding.

262
00:11:57,710 --> 00:12:02,225
And let's see.

263
00:12:02,225 --> 00:12:04,414
So that's one thing.

264
00:12:04,414 --> 00:12:08,225
There's the people waiting
for the seminar to begin.

265
00:12:08,225 --> 00:12:10,579
That's me with Doug Hofstadter.

266
00:12:10,579 --> 00:12:15,499
How many people know who Doug
Hofstadter is? About three.

267
00:12:15,499 --> 00:12:17,270
So there's a book called girdle

268
00:12:17,270 --> 00:12:20,525
Escher Bach and
eternal golden braid.

269
00:12:20,525 --> 00:12:24,379
And if you want to
know about ideas,

270
00:12:24,379 --> 00:12:27,080
about how logic and
human thinking and

271
00:12:27,080 --> 00:12:31,114
consciousness might all
interact with each other.

272
00:12:31,114 --> 00:12:33,125
That's a good book to read.

273
00:12:33,125 --> 00:12:36,229
How many people have heard
the term Strange Loop?

274
00:12:36,229 --> 00:12:38,839
There's not, I'm nobody.

275
00:12:38,839 --> 00:12:42,484
Ok. There's a developer
conference called Strange Loop,

276
00:12:42,484 --> 00:12:44,029
and currently there's
actually a play

277
00:12:44,029 --> 00:12:45,994
on Broadway called Strange Loop,

278
00:12:45,994 --> 00:12:47,599
named after this term

279
00:12:47,599 --> 00:12:49,399
from Doug's book
size I holding you,

280
00:12:49,399 --> 00:12:51,604
you'd have to go to New
York and see the play.

281
00:12:51,604 --> 00:12:54,169
And he said, well,
they're sold out.

282
00:12:54,169 --> 00:12:57,330
So that makes it
difficult for him.

283
00:12:57,460 --> 00:13:01,879
And then this is Ledi Hall at
the University of Indiana.

284
00:13:01,879 --> 00:13:04,279
So I also went to the
University of Indiana and

285
00:13:04,279 --> 00:13:07,129
went to Northwestern
University in Chicago.

286
00:13:07,129 --> 00:13:10,849
And so this is Ledi
Hall in Chicago.

287
00:13:10,849 --> 00:13:12,334
It's a very nice building,

288
00:13:12,334 --> 00:13:15,750
almost as nice as our
Informatics Forum.

289
00:13:16,130 --> 00:13:19,160
I'm being inconsistent
because when I spoke to them,

290
00:13:19,160 --> 00:13:20,600
I said our Informatics form is

291
00:13:20,600 --> 00:13:23,239
almost as nice as Ledi Hall.

292
00:13:23,239 --> 00:13:27,214
And they have a very nice
sculpture in the top of it.

293
00:13:27,214 --> 00:13:30,170
So this is a, this is
an active sculpture.

294
00:13:30,170 --> 00:13:32,255
It, it actually
has sensors in it.

295
00:13:32,255 --> 00:13:33,649
And if you move around, some of

296
00:13:33,649 --> 00:13:35,540
the lights will change and so on.

297
00:13:35,540 --> 00:13:36,829
When it's working, of course,

298
00:13:36,829 --> 00:13:39,185
it was turned off
when I was there.

299
00:13:39,185 --> 00:13:41,644
But it's a nice sculpture.

300
00:13:41,644 --> 00:13:43,159
And I am really jealous of this

301
00:13:43,159 --> 00:13:44,630
because when they built
the informatics for him,

302
00:13:44,630 --> 00:13:46,040
they said, oh, we should do

303
00:13:46,040 --> 00:13:48,440
some nice kind of
interactive sculpture.

304
00:13:48,440 --> 00:13:51,050
And what they ended
up doing is something

305
00:13:51,050 --> 00:13:54,960
with names of the donors
to the building in ascii,

306
00:13:55,030 --> 00:13:59,990
which you can see in the lobby
of the Informatics form.

307
00:13:59,990 --> 00:14:02,420
So this I think, is
a much better idea

308
00:14:02,420 --> 00:14:04,205
of an interactive artwork.

309
00:14:04,205 --> 00:14:06,500
And I play tourist in Chicago.

310
00:14:06,500 --> 00:14:08,539
So there's me playing
tourists in Chicago.

311
00:14:08,539 --> 00:14:10,594
How many people
know what the funny

312
00:14:10,594 --> 00:14:13,279
mirrored thing and the bottom is?

313
00:14:13,279 --> 00:14:17,760
Yep. You're gone.

314
00:14:18,760 --> 00:14:26,999
Do you know its name? Does
anybody know the name?

315
00:14:29,380 --> 00:14:32,584
Right. So they locally
they call it the bean.

316
00:14:32,584 --> 00:14:35,749
The actual name is the
Cloud Gate and it's by

317
00:14:35,749 --> 00:14:39,320
an artist named Kapoor.

318
00:14:39,320 --> 00:14:42,545
Can't remember his first
State SAP knows firstname.

319
00:14:42,545 --> 00:14:46,949
Sorry, Amish cohort. Thank you.

320
00:14:47,230 --> 00:14:49,370
So it's very nice artwork.

321
00:14:49,370 --> 00:14:51,244
It's one of my favorite
things actually.

322
00:14:51,244 --> 00:14:52,849
And you can see there
are lots of tourists

323
00:14:52,849 --> 00:14:55,949
around it looking at
it, it's great fun.

324
00:14:56,050 --> 00:14:58,970
And if you ever see
the movie source code,

325
00:14:58,970 --> 00:15:01,099
which is a great name
because it makes it sound

326
00:15:01,099 --> 00:15:03,590
like it's about writing
code for a computer,

327
00:15:03,590 --> 00:15:06,360
but it's actually
about time travel.

328
00:15:07,390 --> 00:15:11,930
There's a scene that
takes place at the beam.

329
00:15:11,930 --> 00:15:13,460
So that was me playing tourist.

330
00:15:13,460 --> 00:15:17,074
Okay. You can put that away.

331
00:15:17,074 --> 00:15:19,654
So so that's my trip report.

332
00:15:19,654 --> 00:15:21,290
Any questions?

333
00:15:21,290 --> 00:15:23,660
Based on the Trip
Report or me wintering

334
00:15:23,660 --> 00:15:26,639
on about how important
maintenance is.

335
00:15:26,770 --> 00:15:32,380
Okay. What's more and
more about recursion?

336
00:15:32,380 --> 00:15:36,500
Yeah, okay, let's learn
more about recursion.

337
00:15:45,030 --> 00:15:54,680
And the reason, right?
That's why there we go.

338
00:15:54,690 --> 00:15:57,279
I think we should
try that one again.

339
00:15:57,279 --> 00:15:59,845
Recursions, really
exciting, right?

340
00:15:59,845 --> 00:16:05,750
Who want to learn more about
recursion? There we go.

341
00:16:08,250 --> 00:16:14,350
Okay, so first thing we learn
is how to count, right?

342
00:16:14,350 --> 00:16:18,954
So we know how to do this
in the sense that if

343
00:16:18,954 --> 00:16:28,060
I want a blank window,

344
00:16:28,060 --> 00:16:30,529
yes, there's a blank window.

345
00:16:53,610 --> 00:17:01,465
Let's do. Okay, so

346
00:17:01,465 --> 00:17:03,129
if I do just take

347
00:17:03,129 --> 00:17:06,039
a completely blank
window and their galaxy,

348
00:17:06,039 --> 00:17:08,380
right, we know how to
count because we can just

349
00:17:08,380 --> 00:17:13,120
type one dot dot ten, right?

350
00:17:13,120 --> 00:17:15,280
It will count up to ten force.

351
00:17:15,280 --> 00:17:19,430
Or we can count
one dot, dot 1000.

352
00:17:20,220 --> 00:17:23,559
And it will count
up to 1000 fourths.

353
00:17:23,559 --> 00:17:26,889
So you all know how to write that

354
00:17:26,889 --> 00:17:28,359
in Haskell and that's the way you

355
00:17:28,359 --> 00:17:30,159
should write hit
most of the time.

356
00:17:30,159 --> 00:17:34,824
But how would you reduce
that down to basic stuff?

357
00:17:34,824 --> 00:17:37,059
So could you write
that same definition

358
00:17:37,059 --> 00:17:40,484
recursively using what
we've all ready learned.

359
00:17:40,484 --> 00:17:43,624
The answer is yes.

360
00:17:43,624 --> 00:17:46,710
So let's look at that.

361
00:17:47,080 --> 00:17:51,139
Weight. Yep, there we go.

362
00:17:51,139 --> 00:17:54,050
Back to I need to learn

363
00:17:54,050 --> 00:17:56,629
the keys for view
it in full mode.

364
00:17:56,629 --> 00:17:58,775
What does it control?

365
00:17:58,775 --> 00:18:01,025
Apple F, of course.

366
00:18:01,025 --> 00:18:05,765
Alright, control
apple F a, it worked.

367
00:18:05,765 --> 00:18:08,939
Okay, so let's
learn how to count.

368
00:18:09,910 --> 00:18:13,519
Right? So I wrote this
as one dot dot three.

369
00:18:13,519 --> 00:18:15,109
That's actually an abbreviation

370
00:18:15,109 --> 00:18:16,460
for calling a library function

371
00:18:16,460 --> 00:18:20,150
called num from two, right?

372
00:18:20,150 --> 00:18:23,225
And you give it where you
start and where you end.

373
00:18:23,225 --> 00:18:28,069
And so this thing is just an
abbreviation for this thing.

374
00:18:28,069 --> 00:18:33,575
And we do this all the time
in computing is we introduce

375
00:18:33,575 --> 00:18:37,370
a special notation that
just an abbreviation for

376
00:18:37,370 --> 00:18:39,109
something else and
that something else in

377
00:18:39,109 --> 00:18:41,614
our case will usually
be a function call.

378
00:18:41,614 --> 00:18:43,669
Pretty much everything
of interest in

379
00:18:43,669 --> 00:18:47,045
functional programming
is a function,

380
00:18:47,045 --> 00:18:50,570
which is sort of why it's
called functional programming.

381
00:18:50,570 --> 00:18:53,194
I remember, I forgot to
show you about this.

382
00:18:53,194 --> 00:18:57,380
What's this? Like? It's lambda.

383
00:18:57,380 --> 00:19:01,200
And people see what
this thing is.

384
00:19:01,480 --> 00:19:06,589
The funny thing after the
lambda and before the P. So

385
00:19:06,589 --> 00:19:08,239
as I was going to
bring up an image of

386
00:19:08,239 --> 00:19:11,134
this on the web, but
they don't have any.

387
00:19:11,134 --> 00:19:13,340
So I should've taken

388
00:19:13,340 --> 00:19:15,649
a photo of myself and
then showed it to you.

389
00:19:15,649 --> 00:19:19,310
But that's a turnstile that's
a little T on its side.

390
00:19:19,310 --> 00:19:21,454
And that's very
important for logic.

391
00:19:21,454 --> 00:19:23,825
So basically,

392
00:19:23,825 --> 00:19:26,659
functional programming and
logic are so important to

393
00:19:26,659 --> 00:19:28,880
programming languages
that when you design

394
00:19:28,880 --> 00:19:31,759
in that when you open a new
programming language centre,

395
00:19:31,759 --> 00:19:33,964
this is what you put
on your t-shirt.

396
00:19:33,964 --> 00:19:36,005
Functional programming, very dig.

397
00:19:36,005 --> 00:19:38,209
And then a bit of
logic, a bit smaller.

398
00:19:38,209 --> 00:19:40,084
But those are the two
important things.

399
00:19:40,084 --> 00:19:43,084
So you're learning
the right stuff.

400
00:19:43,084 --> 00:19:46,655
Like so. And then as I mentioned,

401
00:19:46,655 --> 00:19:49,279
we tend to use
abbreviations for things.

402
00:19:49,279 --> 00:19:53,090
So this is just a
different way of writing.

403
00:19:53,090 --> 00:19:54,679
This that looks a lot

404
00:19:54,679 --> 00:19:57,215
nicer and it's a
lot easier to read.

405
00:19:57,215 --> 00:19:58,834
There's a name for that.

406
00:19:58,834 --> 00:20:02,795
It's called syntactic sugar.

407
00:20:02,795 --> 00:20:07,114
Syntactic sugar is just the name

408
00:20:07,114 --> 00:20:09,289
for having a different
way of writing

409
00:20:09,289 --> 00:20:11,780
something that's a
bit easier to read.

410
00:20:11,780 --> 00:20:14,764
So then how do we define
the num from two?

411
00:20:14,764 --> 00:20:19,340
So it takes two numbers and
it returns a list of numbers.

412
00:20:19,340 --> 00:20:22,010
And if m is greater than n,

413
00:20:22,010 --> 00:20:24,529
then it returns the empty list.

414
00:20:24,529 --> 00:20:26,959
And if that's not the case,

415
00:20:26,959 --> 00:20:28,609
and M must be less
than or equal to

416
00:20:28,609 --> 00:20:32,134
n. And then m will be the
first number of the list.

417
00:20:32,134 --> 00:20:33,904
And then we do cons,

418
00:20:33,904 --> 00:20:37,775
and then we keep counting
from m plus one.

419
00:20:37,775 --> 00:20:41,705
So the important thing is
your parameter m changes

420
00:20:41,705 --> 00:20:43,910
from m to m plus one,

421
00:20:43,910 --> 00:20:47,855
but your upper bound n
just stays the same.

422
00:20:47,855 --> 00:20:51,844
For one thing changes and the
other one stays the same.

423
00:20:51,844 --> 00:20:55,640
And that sort of pattern where
you've got a function at

424
00:20:55,640 --> 00:20:57,140
some of the arguments change

425
00:20:57,140 --> 00:20:59,329
a little bit and some of
them stayed the same.

426
00:20:59,329 --> 00:21:02,880
To tell you when you
stop is very common.

427
00:21:03,370 --> 00:21:07,534
So let's go through
and execute this.

428
00:21:07,534 --> 00:21:10,460
Entering computer mode.

429
00:21:10,460 --> 00:21:14,419
E num of 13 is

430
00:21:14,419 --> 00:21:19,654
which equation applies
and is one, n is three.

431
00:21:19,654 --> 00:21:22,980
Is one greater than three?

432
00:21:25,240 --> 00:21:27,814
It's one greater than three.

433
00:21:27,814 --> 00:21:29,959
No, no, it's not creative.

434
00:21:29,959 --> 00:21:31,609
It's not using this equation.

435
00:21:31,609 --> 00:21:34,340
Nope, not that one is, let's see,

436
00:21:34,340 --> 00:21:35,809
m less than or equal to n is one

437
00:21:35,809 --> 00:21:38,730
less than or equal to three.

438
00:21:38,740 --> 00:21:41,239
This is the equation I use.

439
00:21:41,239 --> 00:21:43,220
Okay? So now I just copy this

440
00:21:43,220 --> 00:21:46,879
out with m replace by one and

441
00:21:46,879 --> 00:21:53,390
m replace by one and n replaced
by 31 plus one is two.

442
00:21:53,390 --> 00:21:55,625
So this gives me one.

443
00:21:55,625 --> 00:21:58,325
M is one colon,

444
00:21:58,325 --> 00:22:00,979
colon and a known from two of

445
00:22:00,979 --> 00:22:05,704
m plus one and n is the
Num from two of 23.

446
00:22:05,704 --> 00:22:10,054
Okay. I'm all done.

447
00:22:10,054 --> 00:22:11,809
Oh, wait, no, I
need forgot what he

448
00:22:11,809 --> 00:22:13,924
knew from two of 23 is OK.

449
00:22:13,924 --> 00:22:20,629
So that matches this one and
m is now two and l is three.

450
00:22:20,629 --> 00:22:23,644
Ohio State Board.
I don't take work.

451
00:22:23,644 --> 00:22:28,740
We say M is bound to two.

452
00:22:29,260 --> 00:22:32,460
South kinky, doesn't it?

453
00:22:33,670 --> 00:22:40,399
So m is bound to two and
n is bound to three.

454
00:22:40,399 --> 00:22:45,289
So now we can do the same
thing is to create a events

455
00:22:45,289 --> 00:22:52,579
we know is two less
than or equal to three.

456
00:22:52,579 --> 00:22:56,329
Yeah, yes. Okay, so
now we copy again.

457
00:22:56,329 --> 00:22:58,430
And now n becomes two.

458
00:22:58,430 --> 00:23:00,739
And from two N plus one,

459
00:23:00,739 --> 00:23:02,599
N two plus one is three.

460
00:23:02,599 --> 00:23:06,665
So that becomes the
loomed from 233.

461
00:23:06,665 --> 00:23:09,965
Okay? And now we
do the same thing.

462
00:23:09,965 --> 00:23:14,029
Yan is three greater than three?

463
00:23:14,029 --> 00:23:15,949
Not quite.

464
00:23:15,949 --> 00:23:19,025
Almost. Not quite.

465
00:23:19,025 --> 00:23:23,045
Is three less than
or equal to three?

466
00:23:23,045 --> 00:23:26,389
Yes. So we copy it out.

467
00:23:26,389 --> 00:23:31,340
I can now see you're
all saying again,

468
00:23:31,340 --> 00:23:34,550
I'm a computer. I don't care.

469
00:23:34,550 --> 00:23:36,799
I will do the same
thing a zillion

470
00:23:36,799 --> 00:23:39,365
times and I will not get tired.

471
00:23:39,365 --> 00:23:41,269
E di di, di, di, di, di,

472
00:23:41,269 --> 00:23:43,370
di, di, di, di, di.

473
00:23:43,370 --> 00:23:45,919
Ok. So m is three.

474
00:23:45,919 --> 00:23:48,904
And he knew from
two of m plus one.

475
00:23:48,904 --> 00:23:53,749
And so m is 33 plus one is
four and is still three.

476
00:23:53,749 --> 00:23:58,100
So we've got three
Kony num from 243.

477
00:23:58,100 --> 00:24:02,270
Now we go back again is
for greater than three.

478
00:24:02,270 --> 00:24:06,320
Yes. Yea, we finally get
to use the base case.

479
00:24:06,320 --> 00:24:09,484
Ok, so now we just
copy out empty list.

480
00:24:09,484 --> 00:24:11,660
And I've got one cons, two cons,

481
00:24:11,660 --> 00:24:13,490
three cons, empty list,

482
00:24:13,490 --> 00:24:15,965
which is the list 123.

483
00:24:15,965 --> 00:24:19,789
So we're done. Okay, so that it's

484
00:24:19,789 --> 00:24:21,559
quite a roofer ux by

485
00:24:21,559 --> 00:24:23,795
wanted to go through
that in some detail.

486
00:24:23,795 --> 00:24:26,525
You could see there is no
thinking involved, right?

487
00:24:26,525 --> 00:24:28,009
It's very clear that if

488
00:24:28,009 --> 00:24:30,560
this little guy is the
one doing the work,

489
00:24:30,560 --> 00:24:33,709
there's no thinking
involved, right?

490
00:24:33,709 --> 00:24:37,234
It's just following a set
of rules mechanically.

491
00:24:37,234 --> 00:24:39,830
So just we, here we can write out

492
00:24:39,830 --> 00:24:41,180
two lines and then

493
00:24:41,180 --> 00:24:43,804
following those two
lines mechanically,

494
00:24:43,804 --> 00:24:45,620
you can count, you can

495
00:24:45,620 --> 00:24:47,794
form a list of the
numbers between m

496
00:24:47,794 --> 00:24:52,354
and n. Is that clear
enough to people?

497
00:24:52,354 --> 00:24:54,785
Okay. So you now
know how to count.

498
00:24:54,785 --> 00:24:59,129
Are there any questions? Yes.

499
00:25:05,590 --> 00:25:09,000
I'm not quite sure
what you're asking.

500
00:25:09,970 --> 00:25:16,189
Yeah. Or you want
to count by twos.

501
00:25:16,189 --> 00:25:21,619
So you want to go
13579 and then stop.

502
00:25:21,619 --> 00:25:23,029
Ok, good question.

503
00:25:23,029 --> 00:25:24,770
So if you we didn't
want to count by ones,

504
00:25:24,770 --> 00:25:26,779
but we want to count by
some other interval.

505
00:25:26,779 --> 00:25:28,310
How would we change it?

506
00:25:28,310 --> 00:25:31,499
So any idea how
would you change it?

507
00:25:34,000 --> 00:25:37,549
Folks, I'm glad you're
mumbling but MBL very

508
00:25:37,549 --> 00:25:39,080
quietly because
otherwise I can't hear

509
00:25:39,080 --> 00:25:41,819
his answer. So guess.

510
00:25:43,360 --> 00:25:45,829
What we could do is if we want to

511
00:25:45,829 --> 00:25:48,574
count by a certain amount.

512
00:25:48,574 --> 00:25:50,809
In fact, that's actually

513
00:25:50,809 --> 00:25:53,029
another one that's in the
standard library somewhere.

514
00:25:53,029 --> 00:25:55,310
But let's just define it, right?

515
00:25:55,310 --> 00:25:59,910
You knew from two vi.

516
00:26:01,090 --> 00:26:05,270
So let's take an int and

517
00:26:05,270 --> 00:26:10,469
an int and returns a list of int.

518
00:26:13,390 --> 00:26:17,735
Sorry. Oh, right.

519
00:26:17,735 --> 00:26:21,210
Of course it taking
three numbers now.

520
00:26:22,990 --> 00:26:27,140
So M, N and a step.

521
00:26:27,140 --> 00:26:32,644
Let's call it k. So we could,

522
00:26:32,644 --> 00:26:35,569
we could get these names
that were easier to

523
00:26:35,569 --> 00:26:39,480
read like from two and by,

524
00:26:39,580 --> 00:26:43,144
let's do it that way
just to be different.

525
00:26:43,144 --> 00:26:46,024
So there are two
possibilities, right?

526
00:26:46,024 --> 00:26:49,940
Either from is greater than two,

527
00:26:49,940 --> 00:26:52,339
and what do we get in that case?

528
00:26:52,339 --> 00:27:00,710
Empty. Or from is less
than or equal to two.

529
00:27:00,710 --> 00:27:06,154
And so now we've got from cons,

530
00:27:06,154 --> 00:27:10,309
he knew from two by,

531
00:27:10,309 --> 00:27:12,814
and now what do we put here?

532
00:27:12,814 --> 00:27:15,020
So this is, this is two,

533
00:27:15,020 --> 00:27:18,335
this is by and what goes here.

534
00:27:18,335 --> 00:27:20,150
I'm going to ask the
fellow who asked

535
00:27:20,150 --> 00:27:21,289
the question originally to see if

536
00:27:21,289 --> 00:27:28,609
he's from plus bi, right?

537
00:27:28,609 --> 00:27:32,900
From plus by. And
that should work.

538
00:27:32,900 --> 00:27:35,099
Let's see if that works.

539
00:27:39,730 --> 00:27:47,509
From 20 to all confused.

540
00:27:47,509 --> 00:27:49,654
Now, try that again.

541
00:27:49,654 --> 00:27:52,709
Thank you for the music.

542
00:27:53,350 --> 00:27:56,404
I had the weirdest
thing on my keyboard,

543
00:27:56,404 --> 00:27:57,920
which is type why?

544
00:27:57,920 --> 00:28:01,220
Like I just did and puts it
somewhere else on the screen.

545
00:28:01,220 --> 00:28:07,230
I get the beginning of
the thing. Is it only me?

546
00:28:07,870 --> 00:28:11,254
Nobody else has seen that.

547
00:28:11,254 --> 00:28:21,604
Yeah. Yeah, it only
does it for me with y.

548
00:28:21,604 --> 00:28:24,660
What letter does it do for you?

549
00:28:27,370 --> 00:28:30,950
So I think I've got poltergeist.

550
00:28:30,950 --> 00:28:37,910
Okay, so 2V, what will count
from one to ten by two?

551
00:28:37,910 --> 00:28:41,149
It did it. Well done.

552
00:28:41,149 --> 00:28:46,220
Good question. Yep. You don't

553
00:28:46,220 --> 00:28:47,600
think it works in every case.

554
00:28:47,600 --> 00:28:49,369
Good. That's really
important to think about.

555
00:28:49,369 --> 00:28:50,840
What case do you
think it doesn't work

556
00:28:50,840 --> 00:28:55,039
and what happens
if Vi is negative?

557
00:28:55,039 --> 00:28:58,010
Good question. Let's find out.

558
00:28:58,010 --> 00:29:01,999
He knew from two by,

559
00:29:01,999 --> 00:29:05,975
where do I want to count from
ten to one by minus two.

560
00:29:05,975 --> 00:29:10,280
Right? Because we should
count down now, right?

561
00:29:10,280 --> 00:29:11,795
No, so it's not
going to count down.

562
00:29:11,795 --> 00:29:14,134
It only counts up, right?

563
00:29:14,134 --> 00:29:17,269
So it's yet that this is ten,

564
00:29:17,269 --> 00:29:20,360
is not smaller than
one, so we're done.

565
00:29:20,360 --> 00:29:23,690
I can't count up. Well,
it sort of works.

566
00:29:23,690 --> 00:29:29,464
Right? This is count
up from one to ten.

567
00:29:29,464 --> 00:29:34,114
Count up from one to
ten by minus two.

568
00:29:34,114 --> 00:29:36,050
By two, you can already tell

569
00:29:36,050 --> 00:29:37,549
something's going to go wrong.

570
00:29:37,549 --> 00:29:40,385
And what goes wrong
yet just go counts up

571
00:29:40,385 --> 00:29:43,670
forever because it never
reaches ten, right?

572
00:29:43,670 --> 00:29:45,304
So it's counting up to ten,

573
00:29:45,304 --> 00:29:47,640
but it never gets there.

574
00:29:49,060 --> 00:29:58,204
So let's, let's see Ctrl X k
Buffer yet kill that buffer.

575
00:29:58,204 --> 00:30:00,995
No, do not keep the buffer there.

576
00:30:00,995 --> 00:30:03,755
Okay? So, yep, good point.

577
00:30:03,755 --> 00:30:07,220
So this does not work
well if bi is negative.

578
00:30:07,220 --> 00:30:10,265
So we might want to
add another case,

579
00:30:10,265 --> 00:30:12,620
possibly at the beginning.

580
00:30:12,620 --> 00:30:16,579
Right? So one way of
doing this is to say,

581
00:30:16,579 --> 00:30:21,275
if this is the case and
bi is greater than 0,

582
00:30:21,275 --> 00:30:23,840
and this is the case.

583
00:30:23,840 --> 00:30:27,545
And bi is greater than 0.

584
00:30:27,545 --> 00:30:31,819
Or last possibility is by is

585
00:30:31,819 --> 00:30:37,580
less than or equal
to 0 equals error.

586
00:30:37,580 --> 00:30:44,120
That was stupid. Okay. So that

587
00:30:44,120 --> 00:30:45,694
this is a much better program.

588
00:30:45,694 --> 00:30:47,389
Yes. Thank you for
pointing that out.

589
00:30:47,389 --> 00:30:51,420
Good. Any other questions yet?

590
00:30:54,010 --> 00:30:56,420
So just Haskell's a limit as

591
00:30:56,420 --> 00:30:58,775
to how deep recursion can go?

592
00:30:58,775 --> 00:31:03,530
Yes, because the memory on
your computer is limited.

593
00:31:03,530 --> 00:31:05,825
So if you fill up
the whole memory,

594
00:31:05,825 --> 00:31:08,675
then it will say out
of, out of memory.

595
00:31:08,675 --> 00:31:11,725
But computer memories are big.

596
00:31:11,725 --> 00:31:14,990
So generally you don't need
to worry about that limit.

597
00:31:14,990 --> 00:31:17,585
But if you wanted to
do something forever,

598
00:31:17,585 --> 00:31:20,460
then you might need to
worry about that limit.

599
00:31:21,610 --> 00:31:24,334
Very good question.

600
00:31:24,334 --> 00:31:27,050
Good. Okay, good.

601
00:31:27,050 --> 00:31:28,834
You guys are engaged
asking good questions.

602
00:31:28,834 --> 00:31:36,574
Yes. Theoretically there's

603
00:31:36,574 --> 00:31:39,905
there's no, That's right.

604
00:31:39,905 --> 00:31:42,710
You can think of recursion
as going forever,

605
00:31:42,710 --> 00:31:44,239
but you do need to
think of recursion is

606
00:31:44,239 --> 00:31:46,175
using up a little bit of memory.

607
00:31:46,175 --> 00:31:49,460
So sometimes you might

608
00:31:49,460 --> 00:31:51,679
want to compute how much
memory you're going to use,

609
00:31:51,679 --> 00:31:52,970
but generally, you don't

610
00:31:52,970 --> 00:31:55,439
need to worry about
that just yet.

611
00:31:57,790 --> 00:32:01,499
Okay. Let's go on.

612
00:32:02,350 --> 00:32:05,929
That's the one
that's threatening.

613
00:32:05,929 --> 00:32:08,999
Okay, so now we
know how to count.

614
00:32:11,440 --> 00:32:14,295
So factorial, right?

615
00:32:14,295 --> 00:32:17,090
Something that uses
counting, right?

616
00:32:17,090 --> 00:32:19,789
So the factorial of n is
the product from one to

617
00:32:19,789 --> 00:32:23,404
n. So now we know how
we could write that,

618
00:32:23,404 --> 00:32:26,929
which is factorial from one to

619
00:32:26,929 --> 00:32:31,399
n. We can do fat with m and

620
00:32:31,399 --> 00:32:41,074
n. And so notice here
this definition.

621
00:32:41,074 --> 00:32:43,385
This is just a
function definition.

622
00:32:43,385 --> 00:32:45,649
I could just write two
function definitions.

623
00:32:45,649 --> 00:32:49,790
I've written where and this
other definition to indicate

624
00:32:49,790 --> 00:32:52,520
the only place where
this name fact is in

625
00:32:52,520 --> 00:32:55,654
scope is in the definition
of factorial wrap,

626
00:32:55,654 --> 00:32:57,110
the rest of the program,

627
00:32:57,110 --> 00:32:59,689
I would not be able
to invoke back.

628
00:32:59,689 --> 00:33:02,120
I could put it at
the top level like

629
00:33:02,120 --> 00:33:04,984
the other definition and I
could invoke it elsewhere.

630
00:33:04,984 --> 00:33:06,874
But here I'm saying,

631
00:33:06,874 --> 00:33:08,525
No, nobody else is
going to use fat.

632
00:33:08,525 --> 00:33:10,985
So I'll just define it here.

633
00:33:10,985 --> 00:33:12,409
And again, the same thing.

634
00:33:12,409 --> 00:33:14,315
If n is greater
than n, we're done.

635
00:33:14,315 --> 00:33:16,430
So we get the product
of the empty list,

636
00:33:16,430 --> 00:33:21,230
which is 11, y is at one.

637
00:33:21,230 --> 00:33:23,975
Surely it should be
00. So good number.

638
00:33:23,975 --> 00:33:28,474
Why isn't it 0? So what would
happen if we put 0 here?

639
00:33:28,474 --> 00:33:30,800
But you get the product of ten

640
00:33:30,800 --> 00:33:32,929
times nine times eight
times seven times

641
00:33:32,929 --> 00:33:34,789
six times five times four times

642
00:33:34,789 --> 00:33:38,195
three times two
times one times 0.

643
00:33:38,195 --> 00:33:41,555
Because it will end with 0
because we've said 0 here.

644
00:33:41,555 --> 00:33:45,919
And of course the product of
lot of things and 0 is 0.

645
00:33:45,919 --> 00:33:47,720
So that would not work very well.

646
00:33:47,720 --> 00:33:50,464
So we say one, because

647
00:33:50,464 --> 00:33:53,150
if you multiply a
bunch of stuff by one,

648
00:33:53,150 --> 00:33:54,559
it doesn't change it.

649
00:33:54,559 --> 00:33:56,240
So it's a fancy name for that.

650
00:33:56,240 --> 00:33:58,775
Does Avi know the fancy name?

651
00:33:58,775 --> 00:34:04,565
We say that one is the
identity for multiplication.

652
00:34:04,565 --> 00:34:08,495
Or sometimes even
the people that use,

653
00:34:08,495 --> 00:34:13,865
people use as a name for
identity is unit after one,

654
00:34:13,865 --> 00:34:15,904
because this cases so common.

655
00:34:15,904 --> 00:34:20,015
So we can also say one is
the unit for multiplication.

656
00:34:20,015 --> 00:34:22,969
So we'll talk more about
that concept later.

657
00:34:22,969 --> 00:34:25,280
That actually turns out
to be pretty important.

658
00:34:25,280 --> 00:34:26,795
But the important thing is,

659
00:34:26,795 --> 00:34:29,975
don't use 0 all the time.

660
00:34:29,975 --> 00:34:34,504
Use identity, use whatever
is the appropriate identity.

661
00:34:34,504 --> 00:34:36,199
Depending on your operation,

662
00:34:36,199 --> 00:34:39,170
0 is the unit of
something very important.

663
00:34:39,170 --> 00:34:45,005
What is 0, the unit for the
identity for addition, right?

664
00:34:45,005 --> 00:34:47,045
0 is the unit for addition.

665
00:34:47,045 --> 00:34:50,700
0 plus thingy is thingy.

666
00:34:51,430 --> 00:34:55,174
So 0 is important when
we're doing sums.

667
00:34:55,174 --> 00:34:58,050
But for products we use one.

668
00:35:00,790 --> 00:35:04,565
Ok, and so does everybody
see how factorial works?

669
00:35:04,565 --> 00:35:07,819
And notice that I'm

670
00:35:07,819 --> 00:35:11,039
going to copy this one out.
Let's see if I can do that.

671
00:35:11,620 --> 00:35:13,670
I'm just going to
show you a couple of

672
00:35:13,670 --> 00:35:16,259
variants on how we could do this.

673
00:35:17,440 --> 00:35:21,110
That that's wrong. That's right.

674
00:35:21,110 --> 00:35:30,994
Yay. That didn't
come out very well.

675
00:35:30,994 --> 00:35:33,109
Alright, try that.

676
00:35:33,109 --> 00:35:36,630
Right, so we can just try it out.

677
00:35:42,040 --> 00:35:45,960
For factorial is yep,
that one worked.

678
00:35:51,130 --> 00:35:53,674
I notice I've said here into it,

679
00:35:53,674 --> 00:35:55,669
I probably shouldn't
have said that.

680
00:35:55,669 --> 00:35:58,219
So Haskell's a bit funny.

681
00:35:58,219 --> 00:36:00,169
Some things only work with int,

682
00:36:00,169 --> 00:36:02,480
which is why we tend to use int.

683
00:36:02,480 --> 00:36:06,660
But it really should be
integer all the time.

684
00:36:07,480 --> 00:36:11,850
Because then it will work
even with very large numbers.

685
00:36:13,750 --> 00:36:18,740
Oh, that didn't work at all.

686
00:36:18,740 --> 00:36:22,439
Oh, I know why because
I didn't reload it.

687
00:36:28,750 --> 00:36:38,900
What have I done wrong?
This one still wrong.

688
00:36:38,900 --> 00:36:40,949
Very good point.

689
00:36:47,890 --> 00:36:51,450
We go let's try that again.

690
00:36:55,180 --> 00:36:58,789
Yeah, not works the
business by the way,

691
00:36:58,789 --> 00:37:01,130
why you want to
use integer rather

692
00:37:01,130 --> 00:37:04,709
than int whenever you can.

693
00:37:13,540 --> 00:37:16,459
Okay? Right. So I

694
00:37:16,459 --> 00:37:17,660
just want to show you
a couple of things.

695
00:37:17,660 --> 00:37:19,249
One thing is, alright,

696
00:37:19,249 --> 00:37:24,350
if we didn't do that,
it still works.

697
00:37:24,350 --> 00:37:26,690
It does, does the same
thing with flowed.

698
00:37:26,690 --> 00:37:35,770
It. But now I

699
00:37:35,770 --> 00:37:37,225
can also call fact.

700
00:37:37,225 --> 00:37:39,685
So if I say that
I'm one to a 100,

701
00:37:39,685 --> 00:37:41,474
it gives us the same thing.

702
00:37:41,474 --> 00:37:45,250
I could also call
fact if 99 to 100,

703
00:37:45,250 --> 00:37:52,880
if I wanted to wear as right
when I have the Waring here.

704
00:37:57,810 --> 00:38:02,860
No, load it. There we go.

705
00:38:02,860 --> 00:38:05,950
Now, write factorial wrecked

706
00:38:05,950 --> 00:38:08,930
still does exactly
the same thing.

707
00:38:09,750 --> 00:38:14,019
But fat.

708
00:38:14,019 --> 00:38:18,820
He's now not in scope variable,

709
00:38:18,820 --> 00:38:21,504
not in scope fact.

710
00:38:21,504 --> 00:38:25,689
Ok. And this pattern where I

711
00:38:25,689 --> 00:38:29,289
wanted to find something like
the factorial up to end,

712
00:38:29,289 --> 00:38:31,029
but to do it, I need

713
00:38:31,029 --> 00:38:33,219
this other thing that's
changing, right?

714
00:38:33,219 --> 00:38:36,010
I need this m, this lower
bound I'm counting up.

715
00:38:36,010 --> 00:38:40,179
So I define another function
that has one extra argument,

716
00:38:40,179 --> 00:38:43,434
and then it's that extra
argument that changes.

717
00:38:43,434 --> 00:38:46,810
That's a really,
really common pattern.

718
00:38:46,810 --> 00:38:49,554
So I know you all know
how to do factorial.

719
00:38:49,554 --> 00:38:52,899
But the reason I'm showing
you this is this idea, oh,

720
00:38:52,899 --> 00:38:54,520
I need to define a function with

721
00:38:54,520 --> 00:38:56,879
one argument that
finds the factorial.

722
00:38:56,879 --> 00:38:59,420
But to do it, I need
to remember that

723
00:38:59,420 --> 00:39:00,739
upper bound while having another

724
00:39:00,739 --> 00:39:02,030
thing that's counting up.

725
00:39:02,030 --> 00:39:03,635
So to define factorial,

726
00:39:03,635 --> 00:39:07,909
I need another function,
a helper function.

727
00:39:07,909 --> 00:39:11,179
That oops, excuse me,

728
00:39:11,179 --> 00:39:14,550
a helper function that

729
00:39:15,130 --> 00:39:18,815
has an additional
argument that can vary.

730
00:39:18,815 --> 00:39:20,630
That's what we've done here.

731
00:39:20,630 --> 00:39:23,839
So we just want factorial
of n. But to do it,

732
00:39:23,839 --> 00:39:26,689
we do it in terms of the
helper function fact of

733
00:39:26,689 --> 00:39:30,750
n And n. Okay?

734
00:39:35,080 --> 00:39:37,999
And if I want to be
consistent naming,

735
00:39:37,999 --> 00:39:41,000
this would be call that
coil wreck helper.

736
00:39:41,000 --> 00:39:43,389
But I hate really long names,

737
00:39:43,389 --> 00:39:45,215
so I've just called it fact.

738
00:39:45,215 --> 00:39:48,949
And because this name is
only in scope for here,

739
00:39:48,949 --> 00:39:50,239
it's perfectly fine to pick

740
00:39:50,239 --> 00:39:51,980
a short name because you only

741
00:39:51,980 --> 00:39:54,469
need to remember it
for this definition.

742
00:39:54,469 --> 00:39:57,630
Ok, questions about that.

743
00:39:58,720 --> 00:40:01,759
What else have we got today?

744
00:40:01,759 --> 00:40:06,230
So we can go through and do
it in exactly the same way.

745
00:40:06,230 --> 00:40:10,355
Who wants to see it? That
done by the stupid computer.

746
00:40:10,355 --> 00:40:12,380
Who is bored and doesn't want to

747
00:40:12,380 --> 00:40:15,060
see it done by the
stupid computer.

748
00:40:16,180 --> 00:40:20,315
Who didn't raise their hands
either of those times.

749
00:40:20,315 --> 00:40:24,840
Right? You guys are not engaged.

750
00:40:25,720 --> 00:40:28,114
I'll do that again. Come on.

751
00:40:28,114 --> 00:40:30,260
Who wants to see it again?

752
00:40:30,260 --> 00:40:33,124
Who doesn't want to see it again?

753
00:40:33,124 --> 00:40:34,640
Yeah, that's what I thought.

754
00:40:34,640 --> 00:40:40,579
Okay. And then we
could do something.

755
00:40:40,579 --> 00:40:43,850
We can also count
forever in Haskell.

756
00:40:43,850 --> 00:40:46,830
So you can do something like

757
00:40:51,670 --> 00:40:59,254
if we say 0 dot
dot There it goes.

758
00:40:59,254 --> 00:41:01,294
It's not going to stop.

759
00:41:01,294 --> 00:41:03,860
Right? So we already saw
wave doing this, right?

760
00:41:03,860 --> 00:41:09,230
What we were trying to count
by minus two up to ten.

761
00:41:09,230 --> 00:41:12,570
Again, we got something
like this that didn't stop.

762
00:41:12,790 --> 00:41:15,529
Let's see, just control SCC work.

763
00:41:15,529 --> 00:41:22,865
No. Okay. Well, just
to kill that window.

764
00:41:22,865 --> 00:41:24,544
Yes. Please die.

765
00:41:24,544 --> 00:41:34,475
Yes. Please. Di
tri got wet again.

766
00:41:34,475 --> 00:41:38,160
The acquit That sounds like a no.

767
00:41:39,070 --> 00:41:45,095
Control x k. Okay.
Keep the buffer.

768
00:41:45,095 --> 00:41:47,914
No, vary, go, yay.

769
00:41:47,914 --> 00:41:53,074
Okay. What, what
else have we got?

770
00:41:53,074 --> 00:41:55,970
So now we've got zip.

771
00:41:55,970 --> 00:42:01,309
Zip takes a list of things and

772
00:42:01,309 --> 00:42:03,304
another list of things
and returns a list of

773
00:42:03,304 --> 00:42:06,515
pairs of corresponding elements.

774
00:42:06,515 --> 00:42:11,195
So few zip 012 with ABC,

775
00:42:11,195 --> 00:42:16,730
you get, alright, we can
run this one, right?

776
00:42:16,730 --> 00:42:19,770
Go back to Yeah.

777
00:42:24,030 --> 00:42:31,150
Alright, zip three with ABC.

778
00:42:31,150 --> 00:42:33,519
And that gives us, And remember,

779
00:42:33,519 --> 00:42:35,680
right when we say ABC,

780
00:42:35,680 --> 00:42:37,900
Of course that's just again

781
00:42:37,900 --> 00:42:43,180
that syntactic sugar for that.

782
00:42:43,180 --> 00:42:44,995
So that's why you get that.

783
00:42:44,995 --> 00:42:49,389
So just pairs of corresponding
elements of the list.

784
00:42:49,389 --> 00:42:52,689
And the way that works is, okay,

785
00:42:52,689 --> 00:42:54,205
we were talking about
corresponding outlets by

786
00:42:54,205 --> 00:42:56,019
either list in fact
might be empty.

787
00:42:56,019 --> 00:42:58,765
So as soon as one list
is empty, we stop.

788
00:42:58,765 --> 00:43:00,895
And if they're both non-empty,

789
00:43:00,895 --> 00:43:05,594
repair the first element
of the first one,

790
00:43:05,594 --> 00:43:07,894
the first element
of the second one.

791
00:43:07,894 --> 00:43:10,339
So the first on the left
with the first on the right.

792
00:43:10,339 --> 00:43:13,159
And then we
recursively zip again.

793
00:43:13,159 --> 00:43:14,599
And you can see that yep,

794
00:43:14,599 --> 00:43:17,599
that would take pair
0 with a and then do

795
00:43:17,599 --> 00:43:21,635
zip of 12x and BC and then pair.

796
00:43:21,635 --> 00:43:23,659
Now we'll test the
front is one and b,

797
00:43:23,659 --> 00:43:26,029
so we get one and
b may zip two with

798
00:43:26,029 --> 00:43:28,940
C. Two and C are at the front.

799
00:43:28,940 --> 00:43:31,745
And then we get zip
of two empty things.

800
00:43:31,745 --> 00:43:34,115
So it's either it's
empty, it becomes empty.

801
00:43:34,115 --> 00:43:37,200
And so that's why
we get that answer.

802
00:43:38,620 --> 00:43:43,145
And in fact, there are two
different styles, right?

803
00:43:43,145 --> 00:43:45,289
I've sort of used
the laid-back style,

804
00:43:45,289 --> 00:43:47,944
which is what you find
in the standard library.

805
00:43:47,944 --> 00:43:54,125
It will stop as soon as
one list becomes empty.

806
00:43:54,125 --> 00:43:56,390
The other way is, is
this way which says

807
00:43:56,390 --> 00:43:58,744
they must both be empty
at the same time.

808
00:43:58,744 --> 00:44:00,349
And here, if you gave it to lists

809
00:44:00,349 --> 00:44:03,439
of different length,
it would complain.

810
00:44:03,439 --> 00:44:05,764
I would say no.

811
00:44:05,764 --> 00:44:08,269
When one builds splints out
and the other one hasn't,

812
00:44:08,269 --> 00:44:09,484
it said it would say,

813
00:44:09,484 --> 00:44:11,960
I didn't expect
that error, error,

814
00:44:11,960 --> 00:44:16,950
error warning Will Robinson
list of different lengths.

815
00:44:17,140 --> 00:44:20,029
So by and large,

816
00:44:20,029 --> 00:44:22,159
I recommend the Haar style,

817
00:44:22,159 --> 00:44:23,990
but the standard library for

818
00:44:23,990 --> 00:44:25,970
Haskell uses the laid back style.

819
00:44:25,970 --> 00:44:29,824
And that's because there's
this cool trick which is.

820
00:44:29,824 --> 00:44:31,579
Too cool to rule out.

821
00:44:31,579 --> 00:44:33,020
So that's why we're a little bit

822
00:44:33,020 --> 00:44:35,270
dangerous and we allow
lists of different lengths.

823
00:44:35,270 --> 00:44:37,640
And the cool trick is you can do

824
00:44:37,640 --> 00:44:42,209
this. What's that going to do?

825
00:44:44,560 --> 00:44:52,739
Sorry. Slight. What
do you mean by slice?

826
00:44:53,560 --> 00:44:56,645
It's going to slice the string.

827
00:44:56,645 --> 00:45:06,440
Gonna cut into tiny
bits, sort of.

828
00:45:06,440 --> 00:45:08,944
So what it's gonna
do, write this,

829
00:45:08,944 --> 00:45:11,209
paired a number with each
element of the list.

830
00:45:11,209 --> 00:45:12,229
This will also pair

831
00:45:12,229 --> 00:45:14,120
a number with each
element of the list.

832
00:45:14,120 --> 00:45:15,709
Of course it's
counting up from 0.

833
00:45:15,709 --> 00:45:18,110
So it says the thing
at index 0 is a,

834
00:45:18,110 --> 00:45:19,400
at index one is b,

835
00:45:19,400 --> 00:45:21,725
at index two is C, and so on.

836
00:45:21,725 --> 00:45:24,199
And also I'm counting from 0.

837
00:45:24,199 --> 00:45:26,990
That's because I know
the right way to do it.

838
00:45:26,990 --> 00:45:28,249
Some people thank you.

839
00:45:28,249 --> 00:45:33,845
Count from one, they are what
we technically call wrong.

840
00:45:33,845 --> 00:45:36,500
You always start counting from 0,

841
00:45:36,500 --> 00:45:38,850
so that's what Haskell does.

842
00:45:39,040 --> 00:45:43,009
So this just pairs
each home in the list.

843
00:45:43,009 --> 00:45:45,140
So I can do this with
anything, right?

844
00:45:45,140 --> 00:45:48,305
Sip, I want to know
where things are

845
00:45:48,305 --> 00:45:53,970
in a very long sentence.

846
00:45:56,620 --> 00:45:59,750
And you can see the sentences 19

847
00:45:59,750 --> 00:46:02,674
characters long and well,
20 characters long.

848
00:46:02,674 --> 00:46:04,579
And character number
with the index

849
00:46:04,579 --> 00:46:08,704
19 is the 0s at the end
of a very long sentence.

850
00:46:08,704 --> 00:46:11,494
And then what I could do

851
00:46:11,494 --> 00:46:15,409
is as this other function,
you've got it here,

852
00:46:15,409 --> 00:46:20,725
almost done called Search,

853
00:46:20,725 --> 00:46:23,919
which finds the instances
of a character in lists.

854
00:46:23,919 --> 00:46:32,469
So if I say search for E
to E is a single letters,

855
00:46:32,469 --> 00:46:34,059
so that single quotes and

856
00:46:34,059 --> 00:46:38,180
a very long sentence is
a list of characters.

857
00:46:39,660 --> 00:46:43,660
Yep. Oh, what's wrong?

858
00:46:43,660 --> 00:46:45,190
Oh, I didn't load it.

859
00:46:45,190 --> 00:46:52,450
Have to load it up.

860
00:46:52,450 --> 00:46:54,520
Sort of forgotten wrong.

861
00:46:54,520 --> 00:46:57,699
I've got it the other way
round, right? Thank you.

862
00:46:57,699 --> 00:47:05,165
Search a very long sentence

863
00:47:05,165 --> 00:47:08,870
for E. And that says,

864
00:47:08,870 --> 00:47:14,809
okay, 0s occurred at index
3131619 in that list and date,

865
00:47:14,809 --> 00:47:19,170
if we did the other one, zip.

866
00:47:21,310 --> 00:47:26,210
With a very long sentence.

867
00:47:26,210 --> 00:47:36,785
You can see that the 0s
occurred at position 3131619.

868
00:47:36,785 --> 00:47:40,339
Okay. We are at time where
past-time by two minutes.

869
00:47:40,339 --> 00:47:43,140
You will continue
tomorrow. Thank you.
