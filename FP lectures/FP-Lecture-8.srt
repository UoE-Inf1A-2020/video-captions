1
00:00:00,000 --> 00:00:04,635
So we're moving along
at a clip, right?

2
00:00:04,635 --> 00:00:08,909
First you've seen this
exciting idea of data,

3
00:00:08,909 --> 00:00:11,085
things like numbers and strings.

4
00:00:11,085 --> 00:00:14,924
And then you learned about
functions over that data.

5
00:00:14,924 --> 00:00:18,585
And then you learned about things

6
00:00:18,585 --> 00:00:20,849
like recursion as a way of

7
00:00:20,849 --> 00:00:23,519
defining functions
and comprehensions,

8
00:00:23,519 --> 00:00:26,610
as way of defining
functions over lists.

9
00:00:26,610 --> 00:00:30,000
And now we've learned about
higher-order functions,

10
00:00:30,000 --> 00:00:31,469
which captures certain powers

11
00:00:31,469 --> 00:00:33,839
of patterns and computation.

12
00:00:33,839 --> 00:00:37,274
We ended up writing the same
program lots of times over.

13
00:00:37,274 --> 00:00:40,535
We wrote some, we wrote
product, we wrote,

14
00:00:40,535 --> 00:00:42,620
and if all the elements
in the list, we wrote,

15
00:00:42,620 --> 00:00:44,509
concatenate all the
elements of the list

16
00:00:44,509 --> 00:00:46,430
by using a pen, and so on.

17
00:00:46,430 --> 00:00:48,260
And they were all
the same pattern

18
00:00:48,260 --> 00:00:49,880
which could be
captured in a single

19
00:00:49,880 --> 00:00:52,309
function fold R. So

20
00:00:52,309 --> 00:00:55,340
we've learned all
these important ideas.

21
00:00:55,340 --> 00:00:57,544
But remember on the
first day we said,

22
00:00:57,544 --> 00:01:00,394
here you've got some
data like the numbers.

23
00:01:00,394 --> 00:01:03,544
Or here you've got some
data like the lists.

24
00:01:03,544 --> 00:01:06,305
Or here you've got some
data like Booleans.

25
00:01:06,305 --> 00:01:08,600
And they just sort of were

26
00:01:08,600 --> 00:01:10,984
delivered from a
ball above, right?

27
00:01:10,984 --> 00:01:14,554
Fill in his magnitude
when he designed Haskell,

28
00:01:14,554 --> 00:01:16,040
decided there would be

29
00:01:16,040 --> 00:01:18,260
booleans and decided
there would be

30
00:01:18,260 --> 00:01:20,330
numbers and decided
there would be

31
00:01:20,330 --> 00:01:23,759
lists and gifted them unto you.

32
00:01:23,980 --> 00:01:27,065
But wait, you say,

33
00:01:27,065 --> 00:01:30,019
I don't actually believe
Phil is all powerful.

34
00:01:30,019 --> 00:01:34,520
I believe that I might
want my own datatypes.

35
00:01:34,520 --> 00:01:37,204
Where does the data come from?

36
00:01:37,204 --> 00:01:39,005
I hear you ask.

37
00:01:39,005 --> 00:01:41,750
Alright, I don't
hear you asking it.

38
00:01:41,750 --> 00:01:44,314
Where does the data come from?

39
00:01:44,314 --> 00:01:47,195
So that is the exciting thing

40
00:01:47,195 --> 00:01:49,779
that you're going to
learn today, right?

41
00:01:49,779 --> 00:01:52,399
You should be excited because

42
00:01:52,399 --> 00:01:56,029
between the idea of how
you do data declarations,

43
00:01:56,029 --> 00:01:57,334
which I'm showing today.

44
00:01:57,334 --> 00:02:00,139
And the idea of how
you define functions,

45
00:02:00,139 --> 00:02:01,864
which you've seen before.

46
00:02:01,864 --> 00:02:04,445
That's it. That's everything.

47
00:02:04,445 --> 00:02:08,075
You are now all powerful.

48
00:02:08,075 --> 00:02:12,305
We actually have a name
for that in computing.

49
00:02:12,305 --> 00:02:15,110
So congratulate yourselves
after today's lecture,

50
00:02:15,110 --> 00:02:18,620
you will be Turing complete.

51
00:02:18,620 --> 00:02:20,930
And that's a technical word.

52
00:02:20,930 --> 00:02:23,705
But what it means is you
will know how to write

53
00:02:23,705 --> 00:02:28,039
any program that's sensible
to get a computer to execute.

54
00:02:28,039 --> 00:02:30,710
So Turing complete
means as powerful as

55
00:02:30,710 --> 00:02:33,589
anything you could
do with a computer.

56
00:02:33,589 --> 00:02:35,150
That's sort of interesting

57
00:02:35,150 --> 00:02:36,770
that that idea
could be defined in

58
00:02:36,770 --> 00:02:41,614
the 130s just before stored
program computers were built.

59
00:02:41,614 --> 00:02:43,849
We'll talk more about Turing.

60
00:02:43,849 --> 00:02:45,739
Later. I will show
you my stand-up

61
00:02:45,739 --> 00:02:48,749
routine entering on the last day.

62
00:02:49,120 --> 00:02:52,415
But for now, the
important idea is,

63
00:02:52,415 --> 00:02:54,260
there is this important notion of

64
00:02:54,260 --> 00:02:56,539
anything that a computer can do.

65
00:02:56,539 --> 00:02:58,954
This programming language can do.

66
00:02:58,954 --> 00:03:00,890
And Haskell, among many,

67
00:03:00,890 --> 00:03:03,904
many other languages,
is Turing complete.

68
00:03:03,904 --> 00:03:08,764
And today I'm going to unlock
for you the last level.

69
00:03:08,764 --> 00:03:10,250
Well, it's not the last level,

70
00:03:10,250 --> 00:03:13,504
but it's the level that
get you to the full power.

71
00:03:13,504 --> 00:03:17,405
So beyond this, everything
else is just nuance.

72
00:03:17,405 --> 00:03:19,220
After today, you know how to

73
00:03:19,220 --> 00:03:22,980
do anything that you
might want to do.

74
00:03:23,140 --> 00:03:28,340
Are you ready or
some of your ready?

75
00:03:28,340 --> 00:03:31,264
Let's try that again.
Are you ready?

76
00:03:31,264 --> 00:03:36,050
Okay, so the technical name for

77
00:03:36,050 --> 00:03:41,945
this thing is algebraic
data types or ADTs,

78
00:03:41,945 --> 00:03:45,379
sometimes shortened
to algebraic types.

79
00:03:45,379 --> 00:03:50,239
So you can do
everything this way.

80
00:03:50,239 --> 00:03:53,225
So we'll go through
these in more detail.

81
00:03:53,225 --> 00:03:55,490
But Booleans are
an algebraic type.

82
00:03:55,490 --> 00:03:57,199
You can define
things like seasons

83
00:03:57,199 --> 00:03:59,270
or shapes, lists, right?

84
00:03:59,270 --> 00:04:00,905
Which are clearly
very important to us,

85
00:04:00,905 --> 00:04:02,240
are an algebraic type.

86
00:04:02,240 --> 00:04:06,140
Natural numbers are
an algebraic type

87
00:04:06,140 --> 00:04:07,729
that's important because

88
00:04:07,729 --> 00:04:10,609
how many natural
numbers are there?

89
00:04:10,609 --> 00:04:13,415
Right? A lot to

90
00:04:13,415 --> 00:04:17,729
the technical word for that
is an infinite number.

91
00:04:17,800 --> 00:04:21,050
Ok? So there are
really a big number

92
00:04:21,050 --> 00:04:23,509
of naturals and yet all of

93
00:04:23,509 --> 00:04:26,119
them can be written down in

94
00:04:26,119 --> 00:04:31,109
this one line that defines
all the natural numbers.

95
00:04:31,750 --> 00:04:34,640
Expressions write Haskell is

96
00:04:34,640 --> 00:04:36,784
about writing down expressions.

97
00:04:36,784 --> 00:04:38,119
We can actually capture

98
00:04:38,119 --> 00:04:41,299
expressions as a
Haskell datatype,

99
00:04:41,299 --> 00:04:43,220
we can capture trees.

100
00:04:43,220 --> 00:04:45,274
Trees are very important
data structure.

101
00:04:45,274 --> 00:04:47,194
As a Haskell datatype,

102
00:04:47,194 --> 00:04:49,040
there's a type called maybe,

103
00:04:49,040 --> 00:04:51,560
which is what you'll use
if you have a function and

104
00:04:51,560 --> 00:04:52,699
sometimes it knows how to

105
00:04:52,699 --> 00:04:54,994
answer and sometimes it doesn't.

106
00:04:54,994 --> 00:04:57,680
So you want either be able to
say yep, here's the answer,

107
00:04:57,680 --> 00:05:01,129
I've got it or sometimes
want to say, I don't know.

108
00:05:01,129 --> 00:05:02,960
So maybe is very good for

109
00:05:02,960 --> 00:05:06,650
that pairs which
you've already seen.

110
00:05:06,650 --> 00:05:08,390
And, and either type.

111
00:05:08,390 --> 00:05:09,799
So this is like products,

112
00:05:09,799 --> 00:05:12,155
it turns out, and
this is like SMS.

113
00:05:12,155 --> 00:05:16,385
So ordinary operations on
numbers become lifted to

114
00:05:16,385 --> 00:05:18,500
operations on data type thing of

115
00:05:18,500 --> 00:05:20,810
an algebra of data types.

116
00:05:20,810 --> 00:05:25,444
So all of these things can
be done as algebraic types.

117
00:05:25,444 --> 00:05:27,349
Okay, is that clear?
We can all go home

118
00:05:27,349 --> 00:05:29,465
now we can end the lecture early.

119
00:05:29,465 --> 00:05:33,229
Would you want to see a
couple of examples in detail?

120
00:05:33,229 --> 00:05:35,554
Okay, let's do that.

121
00:05:35,554 --> 00:05:37,639
Let's start with the
booleans because this

122
00:05:37,639 --> 00:05:40,069
is something you're
already familiar with.

123
00:05:40,069 --> 00:05:42,574
So we're going to define

124
00:05:42,574 --> 00:05:48,180
the Booleans and write a Boolean
is either false or true.

125
00:05:48,370 --> 00:05:51,619
And not is a function
on Booleans.

126
00:05:51,619 --> 00:05:57,110
And not of false is true
and not of true is false.

127
00:05:57,110 --> 00:06:01,099
And then we have AND, and OR
as functions on Booleans.

128
00:06:01,099 --> 00:06:05,060
And we've got false and
something, it is false.

129
00:06:05,060 --> 00:06:06,650
But we've got true and

130
00:06:06,650 --> 00:06:10,114
something that will just
be the something else.

131
00:06:10,114 --> 00:06:12,109
So this tells us
immediately by the way,

132
00:06:12,109 --> 00:06:14,390
that false is a 04 and,

133
00:06:14,390 --> 00:06:17,039
and the truth, the identity.

134
00:06:17,320 --> 00:06:21,620
And then for, or it's the
other way round false or

135
00:06:21,620 --> 00:06:24,470
something is just the something

136
00:06:24,470 --> 00:06:27,754
but true or something
is always true.

137
00:06:27,754 --> 00:06:29,660
So as soon as you see a false,

138
00:06:29,660 --> 00:06:30,995
it goes to False.

139
00:06:30,995 --> 00:06:33,889
As soon as you see a
true, it goes to true.

140
00:06:33,889 --> 00:06:35,389
And otherwise, if you've got

141
00:06:35,389 --> 00:06:37,204
a list of things that
you're adding together,

142
00:06:37,204 --> 00:06:41,160
you go down the list
and down the list.

143
00:06:41,500 --> 00:06:43,835
Do these look a bit familiar?

144
00:06:43,835 --> 00:06:47,850
Are there any questions
about that gap?

145
00:06:54,370 --> 00:06:58,444
Is it weird that I'm using
functions to define functions?

146
00:06:58,444 --> 00:07:00,350
So can you, so here I've

147
00:07:00,350 --> 00:07:02,720
got three definitions
of functions,

148
00:07:02,720 --> 00:07:06,140
but not, I'm just giving
the definition here.

149
00:07:06,140 --> 00:07:08,255
There no more
functions that appear.

150
00:07:08,255 --> 00:07:10,580
And here there's no more
functions that appear in, here.

151
00:07:10,580 --> 00:07:11,975
There's no more
functions that appear.

152
00:07:11,975 --> 00:07:14,614
Of course in general, you can
use other functions here.

153
00:07:14,614 --> 00:07:16,700
Any other functions
that are defined,

154
00:07:16,700 --> 00:07:18,499
including the
function that you're

155
00:07:18,499 --> 00:07:21,260
defining If you're
using recursion.

156
00:07:21,260 --> 00:07:24,140
So, but here there aren't
any other function,

157
00:07:24,140 --> 00:07:25,399
so I'm not sure if I've got

158
00:07:25,399 --> 00:07:27,899
understood your
question properly.

159
00:07:36,880 --> 00:07:39,170
Right. So you're
thinking there must

160
00:07:39,170 --> 00:07:40,669
be a place where it ends.

161
00:07:40,669 --> 00:07:42,890
So far, everything
has been like that.

162
00:07:42,890 --> 00:07:45,049
So the technical
word for describing

163
00:07:45,049 --> 00:07:47,900
us aren't there some
primitive things?

164
00:07:47,900 --> 00:07:49,924
So some primitive
values like say,

165
00:07:49,924 --> 00:07:52,970
the numbers at some
primitive operations

166
00:07:52,970 --> 00:07:54,859
on them, like addition.

167
00:07:54,859 --> 00:07:57,020
And indeed it,
everything we've showed

168
00:07:57,020 --> 00:07:58,895
you so far, that's true.

169
00:07:58,895 --> 00:08:02,749
And for the computers
we use, that's true.

170
00:08:02,749 --> 00:08:07,264
There must be some
way in which numbers,

171
00:08:07,264 --> 00:08:10,010
like either integers or
floating point numbers

172
00:08:10,010 --> 00:08:13,069
are built into Haskell
and operations like

173
00:08:13,069 --> 00:08:16,310
plus and times on
them are built into

174
00:08:16,310 --> 00:08:20,584
Haskell because they're built
into our computer hardware.

175
00:08:20,584 --> 00:08:23,120
By computers have specialists.

176
00:08:23,120 --> 00:08:26,240
They know especially
about those data formats.

177
00:08:26,240 --> 00:08:27,605
They know specially about

178
00:08:27,605 --> 00:08:29,705
operations on those data formats.

179
00:08:29,705 --> 00:08:32,585
So at some point we
need to tell Haskell,

180
00:08:32,585 --> 00:08:34,220
this is the one you're using.

181
00:08:34,220 --> 00:08:35,689
Use this one because it's

182
00:08:35,689 --> 00:08:38,284
built-in and it will be
much more efficient.

183
00:08:38,284 --> 00:08:40,310
So your question wasn't

184
00:08:40,310 --> 00:08:42,170
about is it functions
all the way down.

185
00:08:42,170 --> 00:08:44,449
Your question was,
are there primitive

186
00:08:44,449 --> 00:08:48,049
datatype somewhere that we
build everything up from?

187
00:08:48,049 --> 00:08:49,280
And the answer is yes.

188
00:08:49,280 --> 00:08:51,515
And you've seen that, however,

189
00:08:51,515 --> 00:08:53,329
the most important
primitive data types

190
00:08:53,329 --> 00:08:55,654
are Booleans and Naturals.

191
00:08:55,654 --> 00:08:59,569
I'm going to show you how
to define those using this.

192
00:08:59,569 --> 00:09:01,789
So the answer is,
we could do it all

193
00:09:01,789 --> 00:09:04,595
with no primitives whatsoever.

194
00:09:04,595 --> 00:09:06,935
Which is really important
because that says,

195
00:09:06,935 --> 00:09:09,979
oh, anything I can
think of, I can do,

196
00:09:09,979 --> 00:09:11,809
I don't need to rely on

197
00:09:11,809 --> 00:09:13,670
the primitives that
somebody else work out

198
00:09:13,670 --> 00:09:15,260
for me a long time

199
00:09:15,260 --> 00:09:17,300
ago and that are built
into the hardware.

200
00:09:17,300 --> 00:09:20,780
I can just do everything
all for myself.

201
00:09:20,780 --> 00:09:25,010
However, if you want to
be a 1000 times faster,

202
00:09:25,010 --> 00:09:27,605
you will use the
built-in primitives.

203
00:09:27,605 --> 00:09:29,929
So that's a really good
question, is saying,

204
00:09:29,929 --> 00:09:32,360
but wait, where do primitives
come into all this?

205
00:09:32,360 --> 00:09:33,710
And the answer is yes,

206
00:09:33,710 --> 00:09:35,179
you do want to use primitives.

207
00:09:35,179 --> 00:09:36,770
You already know all about them,

208
00:09:36,770 --> 00:09:38,404
things like numbers and Booleans.

209
00:09:38,404 --> 00:09:42,395
But you could just cut
them from whole cloth.

210
00:09:42,395 --> 00:09:44,209
There'll be a bit less efficient.

211
00:09:44,209 --> 00:09:45,770
But we're not going
to worry about that

212
00:09:45,770 --> 00:09:49,670
today because efficiency
is the devil's tool.

213
00:09:49,670 --> 00:09:53,570
Okay. So that was a really
good question. Thank you.

214
00:09:53,570 --> 00:09:55,800
Are there other questions?

215
00:09:55,840 --> 00:09:58,430
Okay. And I'll just
show you that all

216
00:09:58,430 --> 00:10:01,349
this works. Let's see.

217
00:10:02,980 --> 00:10:05,164
Oh, that's interesting.

218
00:10:05,164 --> 00:10:15,269
Okay. Yes.

219
00:10:23,280 --> 00:10:26,229
So here's the actual code.

220
00:10:26,229 --> 00:10:28,240
But notice that, right,

221
00:10:28,240 --> 00:10:30,190
Haskell already
has a prelude that

222
00:10:30,190 --> 00:10:32,829
defines bool and true
and false for you.

223
00:10:32,829 --> 00:10:38,695
So here, here I've

224
00:10:38,695 --> 00:10:41,635
just called them my bool
and my false and so on.

225
00:10:41,635 --> 00:10:44,020
So now I've got my nought and my,

226
00:10:44,020 --> 00:10:46,690
and, and my 4x.

227
00:10:46,690 --> 00:10:50,680
And we've also got some other
things like equal and show.

228
00:10:50,680 --> 00:10:52,870
So my knot takes my false to my

229
00:10:52,870 --> 00:10:56,050
True and my true to my false.

230
00:10:56,050 --> 00:10:58,269
And then my, and if
you give it my false,

231
00:10:58,269 --> 00:10:59,724
it returns my false.

232
00:10:59,724 --> 00:11:01,149
But if you give it my true,

233
00:11:01,149 --> 00:11:03,629
it returns the second argument.

234
00:11:03,629 --> 00:11:05,810
So this is just what we saw.

235
00:11:05,810 --> 00:11:10,670
And all I want to show you
is that oh, that's weird.

236
00:11:10,670 --> 00:11:13,775
Okay. Let's kill that one.

237
00:11:13,775 --> 00:11:16,440
Let's have just one at a time.

238
00:11:21,790 --> 00:11:24,110
But here it is loaded up.

239
00:11:24,110 --> 00:11:26,510
So now I can say
something like my

240
00:11:26,510 --> 00:11:32,009
true and my true and what's
that going to return?

241
00:11:32,980 --> 00:11:36,409
Oh, oh, wait, wha,

242
00:11:36,409 --> 00:11:45,780
wha it's my And of course
my true my and my True.

243
00:11:47,080 --> 00:11:49,729
She doesn't know how to print it.

244
00:11:49,729 --> 00:11:54,560
Ok. So if I just ask,

245
00:11:54,560 --> 00:11:57,989
are these two thing that author,

246
00:11:58,000 --> 00:12:00,140
okay, so much for trying to

247
00:12:00,140 --> 00:12:02,119
show you how things
actually work.

248
00:12:02,119 --> 00:12:05,315
There's one more trick
that will you learn later,

249
00:12:05,315 --> 00:12:08,284
which is you can tell
Haskell how to print it.

250
00:12:08,284 --> 00:12:10,549
And in fact, we've gotten
the instance of that

251
00:12:10,549 --> 00:12:12,859
here, but I haven't
done that yet.

252
00:12:12,859 --> 00:12:15,590
So that's why this
one's not quite working

253
00:12:15,590 --> 00:12:18,605
the way we want it to
house. No, no, no, no, no.

254
00:12:18,605 --> 00:12:20,240
Oh, I know what's wrong.

255
00:12:20,240 --> 00:12:22,009
I just need to tell Haskell I

256
00:12:22,009 --> 00:12:23,270
wanted to know how to show it.

257
00:12:23,270 --> 00:12:26,070
So if I say deriving show,

258
00:12:27,850 --> 00:12:36,630
now, let's go into
the right window.

259
00:12:42,640 --> 00:12:46,430
There we go. Now it says
my true, as we'd expect.

260
00:12:46,430 --> 00:12:49,910
You must add this
line deriving show.

261
00:12:49,910 --> 00:12:51,274
If you want to show something,

262
00:12:51,274 --> 00:12:53,989
I'll say a little bit more
about those lines later.

263
00:12:53,989 --> 00:13:03,154
Yes. Yes, you can leave out
the prelude if you want to.

264
00:13:03,154 --> 00:13:04,729
There's a way of doing that.

265
00:13:04,729 --> 00:13:07,895
And I can't remember what it is.

266
00:13:07,895 --> 00:13:12,330
I think it's, we can
try it. Let's see.

267
00:13:14,380 --> 00:13:18,335
I think it's import Prelude.

268
00:13:18,335 --> 00:13:20,255
And then what am I going to
import from the prelude?

269
00:13:20,255 --> 00:13:22,339
Absolutely nothing.

270
00:13:22,339 --> 00:13:25,295
And i, possibly if I do that,

271
00:13:25,295 --> 00:13:28,970
no, right, then I've referred
to string somewhere else.

272
00:13:28,970 --> 00:13:31,319
So that's not going to work.

273
00:13:33,700 --> 00:13:36,770
Maybe if I take this
out, it will work.

274
00:13:36,770 --> 00:13:38,850
Let's find out.

275
00:13:41,050 --> 00:13:44,210
No, now it doesn't know
what show is and so on.

276
00:13:44,210 --> 00:13:46,129
So yes, you can,

277
00:13:46,129 --> 00:13:47,509
but then you need to
figure out which bits of

278
00:13:47,509 --> 00:13:49,789
the prelude you need so you
can print strings and so on.

279
00:13:49,789 --> 00:13:53,420
You can do it, but it
gets a bit fiddly,

280
00:13:54,690 --> 00:13:58,945
Which is why didn't
do it. Okay, good.

281
00:13:58,945 --> 00:14:04,059
Other questions. Yes. Can you

282
00:14:04,059 --> 00:14:05,710
create your own type
classes, right.

283
00:14:05,710 --> 00:14:07,989
So you've read ahead
and you know that

284
00:14:07,989 --> 00:14:10,569
this is referring to something
called a type class.

285
00:14:10,569 --> 00:14:12,670
And that just means
a collection of

286
00:14:12,670 --> 00:14:15,550
things that are not
understood for many,

287
00:14:15,550 --> 00:14:16,750
many different data types.

288
00:14:16,750 --> 00:14:19,389
And we'll talk more about
how to do that later.

289
00:14:19,389 --> 00:14:21,699
So yes, you can define
your own type classes,

290
00:14:21,699 --> 00:14:22,989
but we won't learn
about that now.

291
00:14:22,989 --> 00:14:24,280
For now, just know
that if you want

292
00:14:24,280 --> 00:14:27,385
to have Haskell actually
able to print something,

293
00:14:27,385 --> 00:14:30,080
you have to say deriving show.

294
00:14:31,380 --> 00:14:36,980
Okay, good.

295
00:14:37,170 --> 00:14:40,399
Let's go back to this.

296
00:14:44,010 --> 00:14:47,419
Let's go back to this.

297
00:14:51,390 --> 00:14:53,860
So a couple of other
things we could do with

298
00:14:53,860 --> 00:14:55,705
Booleans are check that they are

299
00:14:55,705 --> 00:14:59,454
equal and also convert
one to a string.

300
00:14:59,454 --> 00:15:05,394
So show bull would take false
to false and true to true.

301
00:15:05,394 --> 00:15:07,059
And then you put this inside

302
00:15:07,059 --> 00:15:08,499
something called a
type class and then

303
00:15:08,499 --> 00:15:10,239
that it's actually this function

304
00:15:10,239 --> 00:15:12,649
that it uses for printing things.

305
00:15:13,440 --> 00:15:16,935
Add this one, let's just say, so.

306
00:15:16,935 --> 00:15:20,810
What does equality return
o it returns a boolean.

307
00:15:20,810 --> 00:15:23,645
Does equality makes sense
for Booleans? Yes, it does.

308
00:15:23,645 --> 00:15:25,265
Are false and false equal?

309
00:15:25,265 --> 00:15:28,145
Yes, they are, are
false and true equal?

310
00:15:28,145 --> 00:15:29,689
No, they're not.

311
00:15:29,689 --> 00:15:33,409
Are true and false
equal? No, they're not.

312
00:15:33,409 --> 00:15:37,654
Are true and true equal
y, yes, they are.

313
00:15:37,654 --> 00:15:40,370
Ok. So even something
like equality,

314
00:15:40,370 --> 00:15:42,589
you can just define by hand,

315
00:15:42,589 --> 00:15:45,769
it does not need to be built in.

316
00:15:45,769 --> 00:15:55,220
Yes. Right? So
another thing that we

317
00:15:55,220 --> 00:16:04,659
could say here is deriving IQ.

318
00:16:04,659 --> 00:16:11,959
And show. There we go.

319
00:16:16,500 --> 00:16:20,749
Oh, and then we need
the prelude back.

320
00:16:22,860 --> 00:16:26,184
And then it works. You
can also derive equality.

321
00:16:26,184 --> 00:16:28,749
And then it knows about
how to do things like Is

322
00:16:28,749 --> 00:16:34,989
true equal to true?

323
00:16:34,989 --> 00:16:37,760
And what's the antibody debate?

324
00:16:38,190 --> 00:16:40,570
Of course, that for
ordinary booleans,

325
00:16:40,570 --> 00:16:42,270
right? We were doing it for.

326
00:16:42,270 --> 00:16:48,769
My booleans, right?

327
00:16:48,769 --> 00:16:50,999
And that returns true.

328
00:16:52,360 --> 00:17:00,889
Other questions. Okay? So you

329
00:17:00,889 --> 00:17:02,779
don't need to do it just
for booleans, right?

330
00:17:02,779 --> 00:17:04,894
You can do for your own things.

331
00:17:04,894 --> 00:17:09,230
So you can have another
form of boolean, right?

332
00:17:09,230 --> 00:17:11,765
Booleans for an
indeterminate logic

333
00:17:11,765 --> 00:17:13,834
where you've got
three truth values,

334
00:17:13,834 --> 00:17:16,700
true, false, and I don't know.

335
00:17:16,700 --> 00:17:18,530
So you could do that, or here

336
00:17:18,530 --> 00:17:20,509
an example is during seasons.

337
00:17:20,509 --> 00:17:22,399
So we've got four seasons,

338
00:17:22,399 --> 00:17:24,890
winter, spring, summer, and fall.

339
00:17:24,890 --> 00:17:26,974
And then we have
an operation next,

340
00:17:26,974 --> 00:17:29,015
which takes a season to season.

341
00:17:29,015 --> 00:17:31,955
So the axes and after
winter is spring,

342
00:17:31,955 --> 00:17:34,474
the next season after
spring is summer.

343
00:17:34,474 --> 00:17:37,430
The next season after
summer is fall,

344
00:17:37,430 --> 00:17:41,640
and the next season
after fall is winter.

345
00:17:45,820 --> 00:17:48,065
And then we can
define things like,

346
00:17:48,065 --> 00:17:50,884
what does it mean for
two seasons to be equal?

347
00:17:50,884 --> 00:17:52,760
And now takes a
season to season that

348
00:17:52,760 --> 00:17:54,500
it returns a bool, right?

349
00:17:54,500 --> 00:17:56,390
Equality always returns a bool.

350
00:17:56,390 --> 00:17:59,000
A winter and winter
or the same spring

351
00:17:59,000 --> 00:18:01,040
and spring are the
same summer in summer,

352
00:18:01,040 --> 00:18:02,269
the same fall and fall.

353
00:18:02,269 --> 00:18:06,320
A. The say, if you've got
any two other things, right?

354
00:18:06,320 --> 00:18:09,050
If one of these four
equation says and apply,

355
00:18:09,050 --> 00:18:11,059
and the stupid
computer falls down to

356
00:18:11,059 --> 00:18:13,519
the bottom of this list,

357
00:18:13,519 --> 00:18:15,469
it will return false.

358
00:18:15,469 --> 00:18:18,200
If they're the same,
we return equal,

359
00:18:18,200 --> 00:18:20,105
and otherwise we return false.

360
00:18:20,105 --> 00:18:22,325
Of course show is very easy.

361
00:18:22,325 --> 00:18:25,925
Winter becomes winter,
spring becomes spring,

362
00:18:25,925 --> 00:18:29,659
somebody becomes summer
and fall becomes fall.

363
00:18:29,659 --> 00:18:35,450
Okay? We could also

364
00:18:35,450 --> 00:18:38,759
have ways of converting
between seasons in integers.

365
00:18:38,759 --> 00:18:40,929
So right to int,
we could say, OK,

366
00:18:40,929 --> 00:18:42,970
I will assign arbitrarily,

367
00:18:42,970 --> 00:18:45,474
winter is 0, spring is one,

368
00:18:45,474 --> 00:18:48,085
summer is two, and fall is three.

369
00:18:48,085 --> 00:18:50,215
And then from it is
determined, right?

370
00:18:50,215 --> 00:18:51,729
Xero better go to winter,

371
00:18:51,729 --> 00:18:53,319
one better go to spring,

372
00:18:53,319 --> 00:18:54,835
to better go to summer.

373
00:18:54,835 --> 00:18:56,784
Three goes to fall,
as you give it.

374
00:18:56,784 --> 00:18:57,879
What happens if I get,

375
00:18:57,879 --> 00:19:01,550
say from int a four,
what will I get?

376
00:19:04,620 --> 00:19:07,299
Right? Says pattern match,

377
00:19:07,299 --> 00:19:09,310
fail or failure to have

378
00:19:09,310 --> 00:19:11,860
exhaustive equations or
something like that.

379
00:19:11,860 --> 00:19:13,719
So we'll just say, sorry,

380
00:19:13,719 --> 00:19:17,335
none of these 34 equations apply.

381
00:19:17,335 --> 00:19:19,510
You will get it wrong.

382
00:19:19,510 --> 00:19:21,739
Shame on you.

383
00:19:22,990 --> 00:19:25,550
Ok. And then we've
got another wave

384
00:19:25,550 --> 00:19:26,600
to finding next, right?

385
00:19:26,600 --> 00:19:30,409
So previously we defined
next by being very specific.

386
00:19:30,409 --> 00:19:33,770
But once we've defined
numbers, right,

387
00:19:33,770 --> 00:19:36,634
we could just say as
converted to an integer,

388
00:19:36,634 --> 00:19:39,800
add one, take it mod four, right?

389
00:19:39,800 --> 00:19:44,029
So mod four means three plus
one is 44, mod four is 0.

390
00:19:44,029 --> 00:19:45,965
So we go back to the
beginning again.

391
00:19:45,965 --> 00:19:47,855
That's what the modest for.

392
00:19:47,855 --> 00:19:49,550
And then convert from an IT.

393
00:19:49,550 --> 00:19:51,379
And you've seen this
sort of thing before.

394
00:19:51,379 --> 00:19:53,360
This is exactly how
you did shifting

395
00:19:53,360 --> 00:19:55,489
in the CaesarCipher. Same idea.

396
00:19:55,489 --> 00:19:57,290
Convert a character to a number,

397
00:19:57,290 --> 00:19:58,834
add something to that number,

398
00:19:58,834 --> 00:20:00,740
take it modulo to
get you back into

399
00:20:00,740 --> 00:20:03,319
the list of 26 characters.

400
00:20:03,319 --> 00:20:04,879
Then convert it back again.

401
00:20:04,879 --> 00:20:08,629
So this should be fairly
familiar to people like this.

402
00:20:08,629 --> 00:20:13,084
If it's familiar and go like
this if it's not familiar.

403
00:20:13,084 --> 00:20:18,680
Okay? And then equality becomes
much easier to dissolve.

404
00:20:18,680 --> 00:20:22,564
Fine, cuz we can say
two seasons are equal.

405
00:20:22,564 --> 00:20:24,514
What will convert
them both to numbers?

406
00:20:24,514 --> 00:20:28,220
And you can see by
looking at this, right,

407
00:20:28,220 --> 00:20:30,739
that if the numbers are
equal than the seasons are

408
00:20:30,739 --> 00:20:32,029
equal and if the numbers are

409
00:20:32,029 --> 00:20:34,145
different than the
seasons are different.

410
00:20:34,145 --> 00:20:38,340
So we can just convert to
numbers and then compare those.

411
00:20:40,210 --> 00:20:45,875
Okay? Ready to speed
up a little bit.

412
00:20:45,875 --> 00:20:51,859
So the next thing we can
do is our data types.

413
00:20:51,859 --> 00:20:54,199
These things can have components.

414
00:20:54,199 --> 00:20:56,734
So circle now takes

415
00:20:56,734 --> 00:21:01,009
a radius and rectangle
takes a width and a height.

416
00:21:01,009 --> 00:21:03,890
And notice I've
just radius, width,

417
00:21:03,890 --> 00:21:05,765
a height, all just
different names

418
00:21:05,765 --> 00:21:07,940
for the floating
point number type.

419
00:21:07,940 --> 00:21:10,444
And I can compute an area.

420
00:21:10,444 --> 00:21:15,259
So the area of a circle is
pi times the radius squared.

421
00:21:15,259 --> 00:21:17,119
Whereas a rectangle with a width

422
00:21:17,119 --> 00:21:18,904
and a height to get its area,

423
00:21:18,904 --> 00:21:20,000
I just take the width and

424
00:21:20,000 --> 00:21:22,610
the height, and I multiply them.

425
00:21:22,610 --> 00:21:29,870
Okay? Now, I should give
you a few buzzwords.

426
00:21:29,870 --> 00:21:32,869
Radius, width, height, float,

427
00:21:32,869 --> 00:21:37,610
and shape are all called types.

428
00:21:37,610 --> 00:21:40,715
In Haskell we have values

429
00:21:40,715 --> 00:21:44,854
like 123 or the
list containing 56.

430
00:21:44,854 --> 00:21:46,309
Those are values.

431
00:21:46,309 --> 00:21:50,524
We have types like
integer, Boolean,

432
00:21:50,524 --> 00:21:55,954
list of integer, list of
list of integer, and so on.

433
00:21:55,954 --> 00:21:58,894
So these are all types.

434
00:21:58,894 --> 00:22:02,540
Now, circle here and wrecked are

435
00:22:02,540 --> 00:22:06,125
more like functions
we can apply them to.

436
00:22:06,125 --> 00:22:07,549
So circle you give it

437
00:22:07,549 --> 00:22:09,890
a floating point and it
gives you back a shape.

438
00:22:09,890 --> 00:22:12,424
Wreck. You give it a
width and a height,

439
00:22:12,424 --> 00:22:14,045
and it gives you back a shape.

440
00:22:14,045 --> 00:22:16,250
So these are basically functions.

441
00:22:16,250 --> 00:22:18,034
This is a right?

442
00:22:18,034 --> 00:22:19,834
Weight by weight functions.

443
00:22:19,834 --> 00:22:21,305
Yes, this is a function.

444
00:22:21,305 --> 00:22:23,420
How many functions
this winter take?

445
00:22:23,420 --> 00:22:27,830
Sorry, how many arguments
does winter tech nun,

446
00:22:27,830 --> 00:22:30,724
right, the 0 cases,
very important.

447
00:22:30,724 --> 00:22:33,829
So this is a function
of no arguments.

448
00:22:33,829 --> 00:22:38,759
And another name for a function
of no arguments is value.

449
00:22:43,000 --> 00:22:45,575
So in this case,

450
00:22:45,575 --> 00:22:47,899
these are functions
that take arguments,

451
00:22:47,899 --> 00:22:50,975
but they are very
special functions.

452
00:22:50,975 --> 00:22:52,684
So they get a special name.

453
00:22:52,684 --> 00:22:56,120
What's special about them is
we cannot only write them on

454
00:22:56,120 --> 00:23:01,430
the right hand side of an
equal sign, like right here.

455
00:23:01,430 --> 00:23:03,200
All right, we've got
things that are returning

456
00:23:03,200 --> 00:23:04,820
different shapes.

457
00:23:04,820 --> 00:23:07,565
And we'll try that again.

458
00:23:07,565 --> 00:23:10,444
We've got things that are
returning different seasons.

459
00:23:10,444 --> 00:23:12,349
And here in a moment
we'll see things that

460
00:23:12,349 --> 00:23:14,825
can return different shapes.

461
00:23:14,825 --> 00:23:17,789
But for right now.

462
00:23:18,940 --> 00:23:23,630
What we're returning is a float.

463
00:23:23,630 --> 00:23:26,075
But here we've got shapes.

464
00:23:26,075 --> 00:23:29,434
We've got shapes on
the left hand side

465
00:23:29,434 --> 00:23:32,254
of an equation in a pattern,

466
00:23:32,254 --> 00:23:35,015
and we match against
that pattern.

467
00:23:35,015 --> 00:23:38,840
So terms appear on the
right of an equation.

468
00:23:38,840 --> 00:23:41,389
Patterns appear on the left.

469
00:23:41,389 --> 00:23:44,870
Every function is a term.

470
00:23:44,870 --> 00:23:47,179
So if it's a
function, you can use

471
00:23:47,179 --> 00:23:49,100
it after the equal sign.

472
00:23:49,100 --> 00:23:52,100
But only things that can be in

473
00:23:52,100 --> 00:23:56,795
patterns can appear to the
left of an equal sign.

474
00:23:56,795 --> 00:24:00,845
So special things go to
the left of an equal sign.

475
00:24:00,845 --> 00:24:07,204
Their name for that special
thing is construct door.

476
00:24:07,204 --> 00:24:12,394
Okay? So I'm telling you is
circle is a constructor.

477
00:24:12,394 --> 00:24:14,825
Rect is a constructor.

478
00:24:14,825 --> 00:24:18,950
If we go back winter,
spring, summer,

479
00:24:18,950 --> 00:24:21,274
and fall, are constructors,

480
00:24:21,274 --> 00:24:24,229
true and false are constructors.

481
00:24:24,229 --> 00:24:26,450
So that means you can
use that anywhere.

482
00:24:26,450 --> 00:24:28,594
You want to use a term

483
00:24:28,594 --> 00:24:31,084
anywhere on the right
of an equal sign,

484
00:24:31,084 --> 00:24:33,395
but also on the left.

485
00:24:33,395 --> 00:24:35,285
So constructors are special.

486
00:24:35,285 --> 00:24:36,980
Those are the only
things that can

487
00:24:36,980 --> 00:24:40,590
go to the left of an equal sign.

488
00:24:48,610 --> 00:24:54,215
Right? And I just want to check,

489
00:24:54,215 --> 00:24:56,089
oh, I've got no examples of

490
00:24:56,089 --> 00:24:57,950
functions on shapes
that return shapes.

491
00:24:57,950 --> 00:25:04,049
That's horrible. Let's give
an example. Oops, yeah.

492
00:25:12,370 --> 00:25:15,080
So right Frisbee,
check this works,

493
00:25:15,080 --> 00:25:17,299
that's OK. And now I

494
00:25:17,299 --> 00:25:20,790
want one thing that takes
a shape to a shape.

495
00:25:22,810 --> 00:25:26,570
Well, one example of a
function that yields

496
00:25:26,570 --> 00:25:29,644
a shape is something that takes

497
00:25:29,644 --> 00:25:36,710
a width and returns a
Shape called square.

498
00:25:36,710 --> 00:25:38,869
And what is square of w going to

499
00:25:38,869 --> 00:25:47,640
return a rectangle whose width
and height are the same.

500
00:25:48,460 --> 00:25:55,550
But again, right, so that loads.

501
00:25:55,550 --> 00:25:56,674
And now I can say,

502
00:25:56,674 --> 00:26:01,685
what is the area of a
square of size ten?

503
00:26:01,685 --> 00:26:04,020
And what's the
answer going to be?

504
00:26:06,460 --> 00:26:11,450
Yes, it's going to be 40 to know.

505
00:26:11,450 --> 00:26:14,869
Okay. How many people think
it's something other than 42?

506
00:26:14,869 --> 00:26:18,030
Okay. What is it? Speak up.

507
00:26:18,850 --> 00:26:27,919
Oh, what us right?

508
00:26:27,919 --> 00:26:31,380
Square is not a constructor.

509
00:26:32,290 --> 00:26:35,255
So it begins with
lowercase letter.

510
00:26:35,255 --> 00:26:39,650
There we go, a 100 because
it's a floating point number.

511
00:26:39,650 --> 00:26:42,659
So it returns a 100.

512
00:26:42,790 --> 00:26:47,540
That actually brings up a
really important point.

513
00:26:47,540 --> 00:26:51,980
Notice that all of our variables,

514
00:26:51,980 --> 00:26:53,464
all of our functions,

515
00:26:53,464 --> 00:26:55,955
begin with a small letter.

516
00:26:55,955 --> 00:27:00,019
All of our types begin
with a capital letter.

517
00:27:00,019 --> 00:27:05,360
All of our constructors
begin with a capital letter.

518
00:27:05,360 --> 00:27:07,700
The reason for this
is so that you can

519
00:27:07,700 --> 00:27:10,099
tell immediately which things are

520
00:27:10,099 --> 00:27:12,830
constructors and which things are

521
00:27:12,830 --> 00:27:15,680
variables or functions, right?

522
00:27:15,680 --> 00:27:17,149
That distinction is so

523
00:27:17,149 --> 00:27:22,685
important that we actually
write them in a different way.

524
00:27:22,685 --> 00:27:27,785
So constructors always begin
with a capital letter.

525
00:27:27,785 --> 00:27:32,000
Functions always begin
with a small letter.

526
00:27:32,000 --> 00:27:34,984
So when can you put
it in a pattern?

527
00:27:34,984 --> 00:27:37,730
If it begins with
a capital letter.

528
00:27:37,730 --> 00:27:39,869
Okay?

529
00:27:53,970 --> 00:27:56,559
Okay, so we can then check,

530
00:27:56,559 --> 00:27:58,405
are two shapes equal?

531
00:27:58,405 --> 00:28:00,520
So two circles will
be equal if they're

532
00:28:00,520 --> 00:28:03,489
both circles and they both
have the same radius.

533
00:28:03,489 --> 00:28:05,979
Two rectangles are
equal if they're

534
00:28:05,979 --> 00:28:08,530
both rectangles
and they both have

535
00:28:08,530 --> 00:28:12,295
the same width and they
both have the same height.

536
00:28:12,295 --> 00:28:14,800
How do we show a CR?

537
00:28:14,800 --> 00:28:17,570
And otherwise they're not equal.

538
00:28:18,210 --> 00:28:20,365
How do you show a shape?

539
00:28:20,365 --> 00:28:23,815
If it's a circle, you say circle,

540
00:28:23,815 --> 00:28:27,370
and then you follow it by
the result of converting the

541
00:28:27,370 --> 00:28:31,940
floating point number r to
a string for rectangle,

542
00:28:31,940 --> 00:28:34,969
say rectangle, and
then the width,

543
00:28:34,969 --> 00:28:36,889
and then a space,

544
00:28:36,889 --> 00:28:39,499
and then the height.

545
00:28:39,499 --> 00:28:41,599
And notice that what
we're printing here is

546
00:28:41,599 --> 00:28:43,310
exactly what Haskell expects

547
00:28:43,310 --> 00:28:46,774
you to type in when you're
typing in one of these things.

548
00:28:46,774 --> 00:28:50,435
And then finally, how do you
show floating point number?

549
00:28:50,435 --> 00:28:54,829
If it's greater than or
equal to 0, just show it.

550
00:28:54,829 --> 00:28:56,419
But if it's negative,

551
00:28:56,419 --> 00:28:58,775
we better put some
parentheses around it.

552
00:28:58,775 --> 00:29:07,445
And that's because if we
said rectangle minus three,

553
00:29:07,445 --> 00:29:12,959
well, let's do circle,
circle minus three.

554
00:29:12,959 --> 00:29:16,105
Sorry, if we say
circle minus three,

555
00:29:16,105 --> 00:29:17,920
it's going to take
its circle minus

556
00:29:17,920 --> 00:29:20,005
three as good say
that's ill typed.

557
00:29:20,005 --> 00:29:23,229
Subtraction expects to numbers
and circle isn't a number.

558
00:29:23,229 --> 00:29:28,639
But if we say circle
minus three, like that.

559
00:29:30,450 --> 00:29:34,880
Oh, that's because I haven't
done deriving hahaha.

560
00:29:49,050 --> 00:30:00,550
Try that again. Right, you
just print circled minus 3.

561
00:30:00,550 --> 00:30:04,780
So minus signs are special and
need to be in parentheses.

562
00:30:04,780 --> 00:30:06,625
Is all that saying?

563
00:30:06,625 --> 00:30:08,650
Because otherwise, it'll think

564
00:30:08,650 --> 00:30:10,880
you're trying to do subtraction.

565
00:30:11,970 --> 00:30:14,439
We can take a vote programming

566
00:30:14,439 --> 00:30:16,944
language design question vote.

567
00:30:16,944 --> 00:30:18,774
So there are two
ways of doing this.

568
00:30:18,774 --> 00:30:19,930
You can either say,

569
00:30:19,930 --> 00:30:21,279
right minus sign is going to be

570
00:30:21,279 --> 00:30:23,289
special and has to
be in parentheses.

571
00:30:23,289 --> 00:30:26,365
Or you can say, unlike all
the rest of mathematics,

572
00:30:26,365 --> 00:30:30,490
we will use a different
symbol for a negative number.

573
00:30:30,490 --> 00:30:32,320
So minus means subtraction,

574
00:30:32,320 --> 00:30:35,050
and we'll use a different
symbol for a negative number.

575
00:30:35,050 --> 00:30:37,839
So Haskell uses the same symbol

576
00:30:37,839 --> 00:30:40,275
for both and then needs
to do things special.

577
00:30:40,275 --> 00:30:42,800
There's a different
language designed here,

578
00:30:42,800 --> 00:30:44,959
standard ML, which just

579
00:30:44,959 --> 00:30:46,339
prints the negative in

580
00:30:46,339 --> 00:30:48,019
front of a number
in a different way.

581
00:30:48,019 --> 00:30:49,820
How many people think
it's better to just make

582
00:30:49,820 --> 00:30:53,000
minus especial case
and use it for both.

583
00:30:53,000 --> 00:30:55,160
How many people
think it'd be better

584
00:30:55,160 --> 00:30:57,570
to use a different symbol?

585
00:30:58,600 --> 00:31:01,850
Ok, and how many people say I'm

586
00:31:01,850 --> 00:31:04,564
not a programming language
designer, I'm not sure.

587
00:31:04,564 --> 00:31:05,840
Give me a room of

588
00:31:05,840 --> 00:31:08,359
a thousand undergraduates
like attest ansi,

589
00:31:08,359 --> 00:31:10,099
which they made fewer errors on.

590
00:31:10,099 --> 00:31:12,600
And then I'd know which to do.

591
00:31:13,450 --> 00:31:17,389
Okay, I'm in the latter class.

592
00:31:17,389 --> 00:31:20,135
Actually, white
people begun to do

593
00:31:20,135 --> 00:31:22,519
these sorts of measurements
for programming languages.

594
00:31:22,519 --> 00:31:26,280
I don't know anybody that's
done that experiment.

595
00:31:26,440 --> 00:31:29,734
In fourth year, you can
do a fourth-year project.

596
00:31:29,734 --> 00:31:33,030
Come see me if you want
to do that experiment.

597
00:31:35,110 --> 00:31:39,059
Right? Okay, let's go back.

598
00:31:41,920 --> 00:31:44,600
Okay, and then we could
make a test, right?

599
00:31:44,600 --> 00:31:46,099
Like is it a circle?

600
00:31:46,099 --> 00:31:48,064
Well fits a circle will say true.

601
00:31:48,064 --> 00:31:50,405
But if it's a rectangle
will say false.

602
00:31:50,405 --> 00:31:53,794
Or we can say things like
get me out the radius.

603
00:31:53,794 --> 00:31:55,460
Radius, right?

604
00:31:55,460 --> 00:31:56,509
If we give it a circle,

605
00:31:56,509 --> 00:31:58,010
it will return its radius.

606
00:31:58,010 --> 00:31:59,419
What happens here?

607
00:31:59,419 --> 00:32:01,889
If we give it a rectangle?

608
00:32:02,950 --> 00:32:08,314
Error, exhaustive
patterns, 88888,

609
00:32:08,314 --> 00:32:10,220
don't do that, right?

610
00:32:10,220 --> 00:32:11,750
So you must give this a circle.

611
00:32:11,750 --> 00:32:13,309
Otherwise it gives
you an error width,

612
00:32:13,309 --> 00:32:15,889
you must give it a
rectangle otherwise.

613
00:32:15,889 --> 00:32:18,350
And notice that if
you use all of these,

614
00:32:18,350 --> 00:32:20,345
you don't need patterns anymore.

615
00:32:20,345 --> 00:32:22,160
You can always just
do things with

616
00:32:22,160 --> 00:32:24,649
if-then-else and on the
right hand side of equation

617
00:32:24,649 --> 00:32:27,275
and you're functions will do

618
00:32:27,275 --> 00:32:30,530
exactly the same thing if
you write them properly,

619
00:32:30,530 --> 00:32:35,480
but they will be twice as long
and half as easy to read.

620
00:32:35,480 --> 00:32:37,640
So that's why we use
pattern matching.

621
00:32:37,640 --> 00:32:41,375
Pattern matching is just
a really great idea.

622
00:32:41,375 --> 00:32:43,610
And I realize I have to
tell you this right?

623
00:32:43,610 --> 00:32:45,544
Pattern matching was invented

624
00:32:45,544 --> 00:32:48,365
here in Edinburgh
BY ROD versatile,

625
00:32:48,365 --> 00:32:51,155
used to be a professor
in this department.

626
00:32:51,155 --> 00:32:53,030
So it's a great idea and you

627
00:32:53,030 --> 00:32:54,935
all have to thank Rod
versatile for it.

628
00:32:54,935 --> 00:32:57,149
I have to thank him too.

629
00:32:57,640 --> 00:33:00,319
So now we can take right area.

630
00:33:00,319 --> 00:33:02,180
We can either write it this way.

631
00:33:02,180 --> 00:33:04,999
The circle if r is pi r
squared and the rectangle is

632
00:33:04,999 --> 00:33:08,359
W5 take or we could
say if it's a circle,

633
00:33:08,359 --> 00:33:11,840
then let R be the radius and
then return pi R squared.

634
00:33:11,840 --> 00:33:13,189
Or if it's a rectangle,

635
00:33:13,189 --> 00:33:14,960
then let W be the width.

636
00:33:14,960 --> 00:33:17,584
H be the height and
Richard W times H,

637
00:33:17,584 --> 00:33:21,079
or otherwise, return
an error message.

638
00:33:21,079 --> 00:33:22,969
So we can do the same thing,

639
00:33:22,969 --> 00:33:25,469
but it becomes much longer.

640
00:33:26,920 --> 00:33:34,049
Ok? So our favorite data
type here is the list.

641
00:33:34,810 --> 00:33:37,115
So can we do list?

642
00:33:37,115 --> 00:33:39,185
Yes, it's just the same thing.

643
00:33:39,185 --> 00:33:44,809
So list now takes a
type parameter, right?

644
00:33:44,809 --> 00:33:51,034
This is a type variable and
it's either nil or a cons,

645
00:33:51,034 --> 00:33:56,340
whose head is a and
whose tail is list of a.

646
00:33:58,230 --> 00:34:02,214
And notice a is I type

647
00:34:02,214 --> 00:34:05,559
variable and it begins
with a small letter.

648
00:34:05,559 --> 00:34:07,434
So it's the same trick.

649
00:34:07,434 --> 00:34:10,000
Type. Names begin
with the capital.

650
00:34:10,000 --> 00:34:13,704
Type variables, begin
with a small letter.

651
00:34:13,704 --> 00:34:17,605
Constructor names
begin with a capital.

652
00:34:17,605 --> 00:34:20,500
Variables like append
value variables

653
00:34:20,500 --> 00:34:23,149
begin with a small letter.

654
00:34:24,300 --> 00:34:26,709
So capital versus small,

655
00:34:26,709 --> 00:34:30,170
it's actually quite
important in Haskell.

656
00:34:33,240 --> 00:34:36,339
And then append, right,

657
00:34:36,339 --> 00:34:40,455
takes two lists and
returns a list.

658
00:34:40,455 --> 00:34:43,055
And how is that defined?

659
00:34:43,055 --> 00:34:48,214
Append of the empty list and y

660
00:34:48,214 --> 00:34:53,510
is just wise append of
cons of x and x's and y's.

661
00:34:53,510 --> 00:34:57,320
Notice the parentheses
here are really important.

662
00:34:57,320 --> 00:35:01,939
Is cons of x and then
append of x's and y's.

663
00:35:01,939 --> 00:35:04,249
And again, the parentheses
here are important.

664
00:35:04,249 --> 00:35:08,179
So all the parentheses
there need to be there.

665
00:35:08,179 --> 00:35:11,330
And you've seen exactly
that definition before,

666
00:35:11,330 --> 00:35:13,879
but we wrote it this way using

667
00:35:13,879 --> 00:35:18,484
double plus and nil and call it.

668
00:35:18,484 --> 00:35:21,350
And all of these declarations

669
00:35:21,350 --> 00:35:23,555
are legal Haskell except for nil.

670
00:35:23,555 --> 00:35:25,999
So that's very, something
very special built in.

671
00:35:25,999 --> 00:35:28,085
But you can define your own.

672
00:35:28,085 --> 00:35:29,734
Again, if you
throughout the prelude,

673
00:35:29,734 --> 00:35:32,075
you can define your own
thing called colon.

674
00:35:32,075 --> 00:35:35,539
If you want to. Wait, wait, wait.

675
00:35:35,539 --> 00:35:37,699
You told be constructors

676
00:35:37,699 --> 00:35:39,800
have to begin with
a capital letter.

677
00:35:39,800 --> 00:35:41,705
If it's all made up of symbols,

678
00:35:41,705 --> 00:35:44,195
how can it began with
a capital letter?

679
00:35:44,195 --> 00:35:48,380
So there's a very funny
I'm constraint in Haskell,

680
00:35:48,380 --> 00:35:52,159
which is if you want to use a
symbol as your constructor,

681
00:35:52,159 --> 00:35:54,740
it must begin with a colon.

682
00:35:54,740 --> 00:35:57,800
And colon begins with a colon.

683
00:35:57,800 --> 00:36:03,570
So capitals for symbols means
it begins with a colon.

684
00:36:04,990 --> 00:36:08,149
So any type name or

685
00:36:08,149 --> 00:36:10,010
any constructor name that's

686
00:36:10,010 --> 00:36:13,200
infix must begin with a colon.

687
00:36:15,580 --> 00:36:18,660
Sorry, that's made of symbols.

688
00:36:18,850 --> 00:36:21,530
Okay? And then the
same trek, right?

689
00:36:21,530 --> 00:36:27,185
You could define is null.

690
00:36:27,185 --> 00:36:30,920
You could define, get the
head from a non-empty list,

691
00:36:30,920 --> 00:36:32,599
get the tail from
a non-empty list.

692
00:36:32,599 --> 00:36:34,580
We've seen all those before.

693
00:36:34,580 --> 00:36:38,870
So all the same tricks work
and we can just do lists.

694
00:36:38,870 --> 00:36:40,670
And then the other
nice thing we can

695
00:36:40,670 --> 00:36:44,055
do is natural numbers.

696
00:36:44,055 --> 00:36:50,080
So again, you can
say data a natural

697
00:36:50,080 --> 00:36:55,960
is either 0 or it's the
successor of a natural.

698
00:36:55,960 --> 00:36:59,049
And then you could say
power, for instance,

699
00:36:59,049 --> 00:37:00,819
who takes a floating
point number and

700
00:37:00,819 --> 00:37:03,504
raises it to a natural number.

701
00:37:03,504 --> 00:37:08,019
So x raised to the 0th
power is always 1.00.

702
00:37:08,019 --> 00:37:11,499
X raised to the successor of n is

703
00:37:11,499 --> 00:37:15,729
X times, so successor of n,

704
00:37:15,729 --> 00:37:19,840
and this is x times
power of x to the n.

705
00:37:19,840 --> 00:37:22,750
So the way you'd
write that out as

706
00:37:22,750 --> 00:37:25,780
a definition in Haskell is
x raised to the 0th power,

707
00:37:25,780 --> 00:37:29,855
is 1, x raised to the nth power.

708
00:37:29,855 --> 00:37:33,185
So this won't be 0 because
0 matches this line.

709
00:37:33,185 --> 00:37:35,209
So x raised to the nth power is x

710
00:37:35,209 --> 00:37:39,720
times x raised to
the n minus one.

711
00:37:39,910 --> 00:37:41,809
At this point you could think,

712
00:37:41,809 --> 00:37:42,529
oh, it would be nice if you

713
00:37:42,529 --> 00:37:44,810
could just write
n plus one there.

714
00:37:44,810 --> 00:37:47,090
And then just write end there.

715
00:37:47,090 --> 00:37:51,065
And Haskell used to support
that as a very special case.

716
00:37:51,065 --> 00:37:53,569
But they took it out. I was
sad when they took it out.

717
00:37:53,569 --> 00:37:56,945
So this is the way you have
to do it in Haskell now.

718
00:37:56,945 --> 00:37:58,789
But it's the same idea.

719
00:37:58,789 --> 00:38:00,920
A number is either
going to be 0 or

720
00:38:00,920 --> 00:38:04,140
it's the successor of
some other number.

721
00:38:05,620 --> 00:38:08,149
And notice that it would take,

722
00:38:08,149 --> 00:38:10,249
right, how do you
write down four here?

723
00:38:10,249 --> 00:38:12,050
We successor of successor of,

724
00:38:12,050 --> 00:38:15,064
successor of successor of 0.

725
00:38:15,064 --> 00:38:19,520
Right? Writing down a million
would take a long time.

726
00:38:19,520 --> 00:38:22,190
But it's very simple notation,

727
00:38:22,190 --> 00:38:23,704
this idea, by the way.

728
00:38:23,704 --> 00:38:25,040
So this idea you can do

729
00:38:25,040 --> 00:38:28,745
every natural number
this way, right?

730
00:38:28,745 --> 00:38:32,854
Natural numbers are
probably as old as people.

731
00:38:32,854 --> 00:38:34,909
Certainly going
back to the Greeks,

732
00:38:34,909 --> 00:38:37,010
they did a lot of
things with numbers.

733
00:38:37,010 --> 00:38:40,085
So 2 thousand years ago
they knew about numbers.

734
00:38:40,085 --> 00:38:42,169
But this trick,
this way of writing

735
00:38:42,169 --> 00:38:44,795
down all infinity
of natural numbers,

736
00:38:44,795 --> 00:38:48,810
that trick only goes to
the mid 18 hundreds.

737
00:38:48,810 --> 00:38:52,720
So data kind thought this

738
00:38:52,720 --> 00:38:56,185
up and p-hat gives Cephei
piano thought this up.

739
00:38:56,185 --> 00:38:57,430
In the mid 18 hundreds.

740
00:38:57,430 --> 00:38:59,275
They were the first
people to do it.

741
00:38:59,275 --> 00:39:02,485
So it's fairly
recent. This trick.

742
00:39:02,485 --> 00:39:05,439
Right? I love classes
where you get to

743
00:39:05,439 --> 00:39:09,709
call something in the mid
18 hundreds, fairly recent.

744
00:39:12,480 --> 00:39:14,859
So and then we can do things like

745
00:39:14,859 --> 00:39:16,899
write adding or
multiplying numbers.

746
00:39:16,899 --> 00:39:20,545
So if we add m to 0, it's m,

747
00:39:20,545 --> 00:39:24,310
but we add m to the successor
of n. That would be

748
00:39:24,310 --> 00:39:26,560
the successor of recursively

749
00:39:26,560 --> 00:39:29,575
adding m and n. If
you think about it,

750
00:39:29,575 --> 00:39:31,394
that will give you
the right thing.

751
00:39:31,394 --> 00:39:33,904
Or again, for multiplication,

752
00:39:33,904 --> 00:39:37,024
if you want to multiply
m by 0, it's 0.

753
00:39:37,024 --> 00:39:39,020
Rightness, this tells us 0

754
00:39:39,020 --> 00:39:41,720
is a right identity for addition.

755
00:39:41,720 --> 00:39:45,484
0 is a white 0 for
multiplication.

756
00:39:45,484 --> 00:39:47,690
And then if you multiply
n by the successor of n,

757
00:39:47,690 --> 00:39:48,994
How will we do that?

758
00:39:48,994 --> 00:39:52,940
We'll multiply m by n.
And now we need one more,

759
00:39:52,940 --> 00:39:55,859
so we add m to it.

760
00:39:58,900 --> 00:40:01,010
And then this is
how you would write

761
00:40:01,010 --> 00:40:05,689
the same things in
ordinary notation.

762
00:40:05,689 --> 00:40:09,274
And let's see, I have this here.

763
00:40:09,274 --> 00:40:11,129
Let's find out.

764
00:40:14,430 --> 00:40:19,749
Yes. We did that one.

765
00:40:19,749 --> 00:40:28,600
Let's do. So what did I do?

766
00:40:28,600 --> 00:40:31,404
It takes two nets.

767
00:40:31,404 --> 00:40:35,694
So x and 0.

768
00:40:35,694 --> 00:40:39,865
I call that m and n
by m and 0 gives us

769
00:40:39,865 --> 00:40:45,189
m and add em to
successor of n gives

770
00:40:45,189 --> 00:40:49,059
us the successor of
recursively adding n and

771
00:40:49,059 --> 00:40:56,895
m. And let's just try it.

772
00:40:56,895 --> 00:41:04,445
Is two plus to add the successor
of the successor of 0.

773
00:41:04,445 --> 00:41:07,190
Well, let's do this more easily.

774
00:41:07,190 --> 00:41:13,130
Let to be the successor of

775
00:41:13,130 --> 00:41:19,969
the successor of 0
footprint to oh yeah.

776
00:41:19,969 --> 00:41:22,949
Let's try this again.

777
00:41:35,110 --> 00:41:43,539
Okay. Too. But SCAP escape he,

778
00:41:43,539 --> 00:41:45,939
escape, escape P. Okay,

779
00:41:45,939 --> 00:41:48,925
now print to that
gives us what we want.

780
00:41:48,925 --> 00:41:58,524
The tension mounts, what
do you think will get j?

781
00:41:58,524 --> 00:42:01,479
Ok, so you can go off and
play stupid computer and

782
00:42:01,479 --> 00:42:04,044
see why it gives you that answer.

783
00:42:04,044 --> 00:42:06,340
You all know enough
to do this now.

784
00:42:06,340 --> 00:42:09,729
So all the things that we
thought were primitive,

785
00:42:09,729 --> 00:42:11,589
we now know how to define.

786
00:42:11,589 --> 00:42:14,199
We don't need to be given
numbers as a primitive.

787
00:42:14,199 --> 00:42:17,305
We can build them up from
scratch using this technique.

788
00:42:17,305 --> 00:42:19,855
We don't need to be given
list as a primitive.

789
00:42:19,855 --> 00:42:23,130
We can build them up
from this technique.

790
00:42:23,130 --> 00:42:25,790
And now tomorrow we'll
start learning how to do

791
00:42:25,790 --> 00:42:28,309
new data structures like tree,

792
00:42:28,309 --> 00:42:31,310
like trees and expression trees.

793
00:42:31,310 --> 00:42:35,309
Okay. Thank you very much.
