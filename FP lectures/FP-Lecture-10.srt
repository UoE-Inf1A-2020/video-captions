1
00:00:01,580 --> 00:00:08,349
Good morning. Are
there any questions?

2
00:00:09,860 --> 00:00:12,539
No questions.

3
00:00:12,539 --> 00:00:22,365
Yes. Do I know the time that
the exams for every subject?

4
00:00:22,365 --> 00:00:28,660
No, I do not. Okay.
Any other questions?

5
00:00:30,620 --> 00:00:35,140
Okay. So last week,

6
00:00:36,980 --> 00:00:39,299
oats decide to autoplay.

7
00:00:39,299 --> 00:00:42,085
No, don't do that. Go away.

8
00:00:42,085 --> 00:00:44,790
Try again.

9
00:00:51,250 --> 00:00:53,704
Last week.

10
00:00:53,704 --> 00:00:56,270
We were looking at

11
00:00:56,270 --> 00:01:00,395
expression trees as
algebraic data types.

12
00:01:00,395 --> 00:01:02,719
And we got through how to

13
00:01:02,719 --> 00:01:07,159
do numerical
expressions like this.

14
00:01:07,159 --> 00:01:11,074
And then we were on to
how to do propositions.

15
00:01:11,074 --> 00:01:12,769
And we got partway through

16
00:01:12,769 --> 00:01:14,525
what you couldn't do
with propositions.

17
00:01:14,525 --> 00:01:18,229
And today I will do the
rest if there's time,

18
00:01:18,229 --> 00:01:21,169
I'll tell you about infinity.

19
00:01:21,169 --> 00:01:25,340
So before I get
started into this,

20
00:01:25,340 --> 00:01:28,859
are there any questions
about expressions?

21
00:01:29,680 --> 00:01:32,720
You're all really
quiet this morning.

22
00:01:32,720 --> 00:01:34,549
I was expecting zillions of

23
00:01:34,549 --> 00:01:37,475
questions about the
class exam tomorrow.

24
00:01:37,475 --> 00:01:42,110
Subclass exam will
be tomorrow at 1110,

25
00:01:42,110 --> 00:01:43,609
our usual meeting time,

26
00:01:43,609 --> 00:01:46,655
and it will extend
for 35 minutes,

27
00:01:46,655 --> 00:01:48,469
I think at 1 I said 50 minutes,

28
00:01:48,469 --> 00:01:51,905
but that's because I forgot
some people get extra time.

29
00:01:51,905 --> 00:01:54,455
So the exam is plan
for 35 minutes.

30
00:01:54,455 --> 00:01:58,099
It's been 35 minutes
every year since 2003,

31
00:01:58,099 --> 00:01:59,240
so I should have
remembered it was

32
00:01:59,240 --> 00:02:02,270
35 minutes, but I forgot.

33
00:02:02,270 --> 00:02:04,985
So the exam will be 35 minutes.

34
00:02:04,985 --> 00:02:06,889
And you will have seen
that on the exam paper?

35
00:02:06,889 --> 00:02:12,995
Yes. If you have not been
told to go elsewhere,

36
00:02:12,995 --> 00:02:14,270
which you might have
been if you have

37
00:02:14,270 --> 00:02:16,474
some special requirements
such as extra time,

38
00:02:16,474 --> 00:02:18,630
the exam will be in here.

39
00:02:19,720 --> 00:02:22,129
And it will be closed book.

40
00:02:22,129 --> 00:02:25,050
And you should bring
a pencil or a pen.

41
00:02:25,380 --> 00:02:28,270
Any other questions?

42
00:02:28,270 --> 00:02:30,789
Oh, I'll just remind you now,

43
00:02:30,789 --> 00:02:32,109
when you take the exam,

44
00:02:32,109 --> 00:02:34,190
write your name on it.

45
00:02:34,740 --> 00:02:39,760
Yes. Yes. Your hand is up.

46
00:02:39,760 --> 00:02:47,480
Yes. Sorry. You need speak up.

47
00:02:51,540 --> 00:02:54,400
No, you don't need to
give import that says

48
00:02:54,400 --> 00:02:57,469
explicitly that you don't
need to get him ports.

49
00:02:58,590 --> 00:03:02,090
Any other questions?

50
00:03:02,400 --> 00:03:04,819
Yes.

51
00:03:17,410 --> 00:03:19,340
Okay, so this

52
00:03:19,340 --> 00:03:20,569
is a good question.

53
00:03:20,569 --> 00:03:24,620
So if you're given a
function to write say,

54
00:03:24,620 --> 00:03:26,929
called F And you even
its type signature.

55
00:03:26,929 --> 00:03:28,820
And then you are given
another function G here.

56
00:03:28,820 --> 00:03:31,084
So G does the same thing as f.

57
00:03:31,084 --> 00:03:32,749
Do you need to write
the type signature

58
00:03:32,749 --> 00:03:33,980
for G as well as F?

59
00:03:33,980 --> 00:03:36,634
Well, strictly speaking, yes,

60
00:03:36,634 --> 00:03:39,739
That's going to be the least
important part obviously.

61
00:03:39,739 --> 00:03:43,109
Because that will
be fairly clear.

62
00:03:43,510 --> 00:03:48,380
Yes. Do you have

63
00:03:48,380 --> 00:03:50,915
to write everything you
import note you do not.

64
00:03:50,915 --> 00:03:52,190
That was the same
question that was

65
00:03:52,190 --> 00:03:53,600
asked previously where I said,

66
00:03:53,600 --> 00:03:54,589
no, you don't need to give

67
00:03:54,589 --> 00:03:55,820
importance on the classics app.

68
00:03:55,820 --> 00:03:57,724
That was my fault for not
repeating the question.

69
00:03:57,724 --> 00:04:05,480
Yes. Is it allowed to use fold?

70
00:04:05,480 --> 00:04:08,539
Well, it's designed to be
answered without using fold.

71
00:04:08,539 --> 00:04:10,669
So if you answer with fold,

72
00:04:10,669 --> 00:04:12,230
you might get some credit for it.

73
00:04:12,230 --> 00:04:15,029
But that wasn't the
intended answer.

74
00:04:19,110 --> 00:04:21,264
Any other questions.

75
00:04:21,264 --> 00:04:23,139
So I didn't repeat the
question by Hope that

76
00:04:23,139 --> 00:04:25,419
was obvious from answered
the question was,

77
00:04:25,419 --> 00:04:28,149
what about using
fold on the exam?

78
00:04:28,149 --> 00:04:30,320
Yeah.

79
00:04:40,080 --> 00:04:42,010
The question should

80
00:04:42,010 --> 00:04:43,780
say which things you can use.

81
00:04:43,780 --> 00:04:46,419
If it doesn't say
and you're in doubt,

82
00:04:46,419 --> 00:04:50,240
ask individually, come over
because it should say.

83
00:04:52,500 --> 00:04:57,590
Did you find any on the
past exams that didn't say

84
00:05:11,230 --> 00:05:14,899
sorry, was there a question
on an exam that didn't

85
00:05:14,899 --> 00:05:16,760
say whether you were
supposed to use

86
00:05:16,760 --> 00:05:19,939
library functions are basic
functions and recursion.

87
00:05:19,939 --> 00:05:24,065
Good. Well, after
come up and tell me

88
00:05:24,065 --> 00:05:26,179
which exam it was and
I will double-check

89
00:05:26,179 --> 00:05:28,744
that because that was mistake
if I did it that way,

90
00:05:28,744 --> 00:05:31,680
I hope there will be
no mistakes this year.

91
00:05:32,260 --> 00:05:35,580
Yep. Anything else?

92
00:05:37,300 --> 00:05:39,830
But ok. Now,

93
00:05:39,830 --> 00:05:43,260
that gets the class
exam out of the way.

94
00:05:44,050 --> 00:05:46,204
The class exam right,

95
00:05:46,204 --> 00:05:48,229
is part of your education.

96
00:05:48,229 --> 00:05:49,580
So I will PV P2,

97
00:05:49,580 --> 00:05:52,580
my favorite quote
from Mark Twain,

98
00:05:52,580 --> 00:05:54,500
sorry, it's part of
the university, right?

99
00:05:54,500 --> 00:05:57,049
And I'll repeat you my favorite
quote from Mark Twain,

100
00:05:57,049 --> 00:05:58,534
which is, don't let school

101
00:05:58,534 --> 00:06:00,169
get in the way of your education.

102
00:06:00,169 --> 00:06:01,730
So the class exam is the school,

103
00:06:01,730 --> 00:06:03,155
but we've got that
out of the way.

104
00:06:03,155 --> 00:06:06,739
And now Jose interested in
education, learning stuff.

105
00:06:06,739 --> 00:06:10,924
Yay. Okay, so any questions about

106
00:06:10,924 --> 00:06:13,610
expression trees or representing

107
00:06:13,610 --> 00:06:16,890
propositions as a data type?

108
00:06:18,790 --> 00:06:24,050
Ok, remember, one of the
most important skills.

109
00:06:24,050 --> 00:06:28,430
You will learn at university
is how to ask a question.

110
00:06:28,430 --> 00:06:30,890
I'm sure some of you are confused

111
00:06:30,890 --> 00:06:33,815
and you're not quite sure
what question to ask.

112
00:06:33,815 --> 00:06:39,815
So you're just like this
not asking the question.

113
00:06:39,815 --> 00:06:41,959
There's also the problem that in

114
00:06:41,959 --> 00:06:44,014
the Scottish education system,

115
00:06:44,014 --> 00:06:45,529
I think sometimes if

116
00:06:45,529 --> 00:06:48,320
in primary school or
secondary school,

117
00:06:48,320 --> 00:06:49,624
you ask a question,

118
00:06:49,624 --> 00:06:50,869
the teacher, so it gives you

119
00:06:50,869 --> 00:06:52,280
a reaction which is like, oh,

120
00:06:52,280 --> 00:06:53,480
well you don't understand

121
00:06:53,480 --> 00:06:55,099
everything perfectly
because you're asking

122
00:06:55,099 --> 00:06:56,929
a question and all
the good students

123
00:06:56,929 --> 00:06:58,294
understand things perfectly.

124
00:06:58,294 --> 00:06:59,720
So you're not as
good as students,

125
00:06:59,720 --> 00:07:02,689
so they start teaching
you not to ask questions.

126
00:07:02,689 --> 00:07:04,859
Has anybody had that?

127
00:07:05,730 --> 00:07:08,709
Very few people have had that?

128
00:07:08,709 --> 00:07:12,685
I think more if you've had
that then are letting on.

129
00:07:12,685 --> 00:07:15,250
So my job is to undo

130
00:07:15,250 --> 00:07:19,299
that and to teach you
to ask questions.

131
00:07:19,299 --> 00:07:22,540
I was once at Oxford sitting at

132
00:07:22,540 --> 00:07:25,795
a job interview for a
lecture ship position,

133
00:07:25,795 --> 00:07:27,639
very prestigious at Oxford.

134
00:07:27,639 --> 00:07:29,530
And they did something,

135
00:07:29,530 --> 00:07:31,509
No, I tell you this story before.

136
00:07:31,509 --> 00:07:34,134
Now. They did
something very mean.

137
00:07:34,134 --> 00:07:36,430
They made all the candidates for

138
00:07:36,430 --> 00:07:38,740
the post attend talks by
the other candidates.

139
00:07:38,740 --> 00:07:40,990
You usually make the
candidates give talks.

140
00:07:40,990 --> 00:07:44,034
You don't make the other
candidates attend the talks.

141
00:07:44,034 --> 00:07:46,119
But they did. That was

142
00:07:46,119 --> 00:07:48,825
little standard
Oxford torture test.

143
00:07:48,825 --> 00:07:51,440
And one of the candidates

144
00:07:51,440 --> 00:07:54,690
asked a question that
every single talk.

145
00:07:55,150 --> 00:07:57,724
His name is Richard Byrd.

146
00:07:57,724 --> 00:07:59,404
He was the one who was hired.

147
00:07:59,404 --> 00:08:01,639
He and I went on to
write a book on Haskell

148
00:08:01,639 --> 00:08:02,930
together called an introduction

149
00:08:02,930 --> 00:08:04,460
to functional programming.

150
00:08:04,460 --> 00:08:11,224
So, so by all means,
don't ask questions.

151
00:08:11,224 --> 00:08:12,589
If you don't want to be appointed

152
00:08:12,589 --> 00:08:13,805
to a lecture ship at Oxford,

153
00:08:13,805 --> 00:08:15,930
that's the way to do it.

154
00:08:16,450 --> 00:08:20,659
Okay, so I'll ask again,
are there any questions?

155
00:08:20,659 --> 00:08:23,749
Alright, let's see
if I can spark some.

156
00:08:23,749 --> 00:08:27,529
So here was a datatype
for propositions.

157
00:08:27,529 --> 00:08:31,775
So we're going to let names
or atoms range over strings.

158
00:08:31,775 --> 00:08:34,040
So these will just be
the variables like P, Q,

159
00:08:34,040 --> 00:08:36,619
and R. And their proposition is

160
00:08:36,619 --> 00:08:40,205
either going to be a
variable with a name or F,

161
00:08:40,205 --> 00:08:41,434
which stands for false,

162
00:08:41,434 --> 00:08:43,759
or T which stands for true or

163
00:08:43,759 --> 00:08:46,714
not applied to
another proposition.

164
00:08:46,714 --> 00:08:51,570
Or, or of two propositions
or end of two propositions.

165
00:08:51,610 --> 00:08:56,030
And or I spelled in
this funny way and,

166
00:08:56,030 --> 00:08:58,430
and I spelled in this funny
way, connect with Colin's.

167
00:08:58,430 --> 00:09:00,809
Can anybody remember why?

168
00:09:01,810 --> 00:09:04,220
Speak up, raise your
hand if you can

169
00:09:04,220 --> 00:09:09,220
remember why. Good, why?

170
00:09:09,220 --> 00:09:15,219
Because, right,

171
00:09:15,219 --> 00:09:16,359
so we can distinguish

172
00:09:16,359 --> 00:09:18,864
constructors from
variables in a pattern.

173
00:09:18,864 --> 00:09:22,989
Constructors always begin with
a capital name variables,

174
00:09:22,989 --> 00:09:24,850
sorry, let me try that again.

175
00:09:24,850 --> 00:09:27,850
Constructors always begin
with a capital letter.

176
00:09:27,850 --> 00:09:31,465
Variables always begin
with a small letter.

177
00:09:31,465 --> 00:09:33,549
And if you've got a symbol,

178
00:09:33,549 --> 00:09:34,869
how do you make a symbol that

179
00:09:34,869 --> 00:09:36,189
begins with a capital letter?

180
00:09:36,189 --> 00:09:38,244
So this is very
funny convention in

181
00:09:38,244 --> 00:09:41,035
Haskell that if it
begins with a colon,

182
00:09:41,035 --> 00:09:43,599
it's a constructor
and otherwise not.

183
00:09:43,599 --> 00:09:46,730
So colon is sort
of capital symbol.

184
00:09:47,040 --> 00:09:52,825
Okay? And then we've
got this deriving here,

185
00:09:52,825 --> 00:09:55,239
which says you can do equality on

186
00:09:55,239 --> 00:09:58,855
these things and you can do
less than on these things.

187
00:09:58,855 --> 00:10:00,850
You can also say deriving Show,

188
00:10:00,850 --> 00:10:02,260
which means it will
print these things out,

189
00:10:02,260 --> 00:10:04,420
but we're going to do our own way

190
00:10:04,420 --> 00:10:06,445
of showing these things.

191
00:10:06,445 --> 00:10:08,710
And then we're going
to use names as

192
00:10:08,710 --> 00:10:10,839
an abbreviation for list of names

193
00:10:10,839 --> 00:10:15,430
and end as an list
of name Bool pairs.

194
00:10:15,430 --> 00:10:18,939
Why would we want a list of
name value pairs, right?

195
00:10:18,939 --> 00:10:21,084
Well, every name
here as a variable.

196
00:10:21,084 --> 00:10:22,210
And what we're saying here is

197
00:10:22,210 --> 00:10:23,379
whether that variable should

198
00:10:23,379 --> 00:10:25,629
be considered as true or

199
00:10:25,629 --> 00:10:27,700
false when we're
working out whether

200
00:10:27,700 --> 00:10:30,610
the proposition is true or false.

201
00:10:30,610 --> 00:10:37,290
So far. P and Q is a
trowel or is it false?

202
00:10:39,790 --> 00:10:44,780
Good answer. Like the answer
to the question p and q.

203
00:10:44,780 --> 00:10:46,280
Is it true or is it false?

204
00:10:46,280 --> 00:10:48,109
As I don't know.

205
00:10:48,109 --> 00:10:49,700
And why don't you know,

206
00:10:49,700 --> 00:10:51,199
because you don't know what P

207
00:10:51,199 --> 00:10:53,479
is and you don't know what Q is.

208
00:10:53,479 --> 00:10:55,895
P is true, Q is true,

209
00:10:55,895 --> 00:10:59,315
P and Q true.

210
00:10:59,315 --> 00:11:01,279
Now it's not true,

211
00:11:01,279 --> 00:11:03,230
true, it's p and q.

212
00:11:03,230 --> 00:11:08,660
So it's true. Okay, so those
are the sorts of questions,

213
00:11:08,660 --> 00:11:10,730
maybe with a little
less violence in

214
00:11:10,730 --> 00:11:12,680
the asking that we

215
00:11:12,680 --> 00:11:15,285
want the computer to
be able to deal with.

216
00:11:15,285 --> 00:11:18,279
Right? So show is just how

217
00:11:18,279 --> 00:11:20,770
we're going to print
out a proposition.

218
00:11:20,770 --> 00:11:24,039
So show converts a
proposition to a string.

219
00:11:24,039 --> 00:11:25,420
So it's a variable.

220
00:11:25,420 --> 00:11:27,115
You just give the variable name.

221
00:11:27,115 --> 00:11:30,895
If it's f, will do F.
If it's TiVo duty.

222
00:11:30,895 --> 00:11:35,020
If it's not, we
will do a tilde E,

223
00:11:35,020 --> 00:11:36,745
which sometimes means not,

224
00:11:36,745 --> 00:11:38,950
followed by the proposition.

225
00:11:38,950 --> 00:11:44,050
If it's or will do the
first proposition,

226
00:11:44,050 --> 00:11:45,670
followed by a vertical bar,

227
00:11:45,670 --> 00:11:47,169
followed by the second.

228
00:11:47,169 --> 00:11:49,795
And if it's, And we'll
do the same with an ad.

229
00:11:49,795 --> 00:11:52,060
And for these last three,

230
00:11:52,060 --> 00:11:53,680
we will put
parentheses around it.

231
00:11:53,680 --> 00:11:55,240
So I'll put an open
parenthesis at

232
00:11:55,240 --> 00:11:57,690
the front of the argument,

233
00:11:57,690 --> 00:12:01,070
par and a closed
parenthesis after.

234
00:12:01,070 --> 00:12:06,635
Is that clear enough that we
can actually execute this?

235
00:12:06,635 --> 00:12:10,859
Let's go ahead and
get it running.

236
00:12:14,410 --> 00:12:21,479
Oops. Let's try that again.

237
00:12:28,690 --> 00:12:32,580
Just, let's get this set up.

238
00:12:42,300 --> 00:12:46,250
I'll just make this
large enough to look at.

239
00:13:16,440 --> 00:13:21,220
Okay, so we've type C,

240
00:13:21,220 --> 00:13:23,260
this always breaks the
screen up into two and away.

241
00:13:23,260 --> 00:13:26,329
I don't like Let's try
doing this differently.

242
00:13:27,060 --> 00:13:29,650
No, it still doesn't that way.

243
00:13:29,650 --> 00:13:39,219
Alright. Alright. Alright, so

244
00:13:39,219 --> 00:13:44,200
here is show just
as we typed it in.

245
00:13:44,200 --> 00:13:46,659
And then if we do,

246
00:13:46,659 --> 00:13:50,334
let's get some testdata and
thank those who've down here.

247
00:13:50,334 --> 00:13:55,329
So here's a proposition and
here's p1, a proposition.

248
00:13:55,329 --> 00:14:01,794
P one says a and B
or not a and not B.

249
00:14:01,794 --> 00:14:04,190
And

250
00:14:11,670 --> 00:14:13,615
there we go.

251
00:14:13,615 --> 00:14:20,420
So now if I say show prop of
p 0, what am I going to get?

252
00:14:21,060 --> 00:14:23,485
Error? I hope I don't get there.

253
00:14:23,485 --> 00:14:29,319
Let's find out. Now. So
I get a string, right?

254
00:14:29,319 --> 00:14:34,240
And it's a and b in parentheses
ord with not a and not B.

255
00:14:34,240 --> 00:14:35,409
And you can see
every time there's

256
00:14:35,409 --> 00:14:38,035
a constructor like and or not,

257
00:14:38,035 --> 00:14:41,109
or it puts parentheses around
it so that the structure

258
00:14:41,109 --> 00:14:44,710
is absolutely clear
and unambiguous.

259
00:14:44,710 --> 00:14:52,490
Okay? I could also just
print out what P itself is.

260
00:14:52,690 --> 00:14:56,179
And notice that that
gives you this,

261
00:14:56,179 --> 00:14:57,649
which looks a little
bit different but has

262
00:14:57,649 --> 00:15:00,359
exactly the same structure.

263
00:15:05,650 --> 00:15:11,249
And then the next important
thing is to evaluate,

264
00:15:13,210 --> 00:15:23,900
to evaluate a term, right?

265
00:15:23,900 --> 00:15:26,794
So we get one line
for each weigh,

266
00:15:26,794 --> 00:15:28,730
each different kind
of constructor.

267
00:15:28,730 --> 00:15:30,139
And noticed that means we've

268
00:15:30,139 --> 00:15:32,345
covered all the possibilities.

269
00:15:32,345 --> 00:15:35,135
And that's very important
when you're writing code.

270
00:15:35,135 --> 00:15:36,664
You want to be sure
you're covering

271
00:15:36,664 --> 00:15:38,314
all the possibilities.

272
00:15:38,314 --> 00:15:39,950
I've seen lots of examples where

273
00:15:39,950 --> 00:15:41,749
people like do the cons case,

274
00:15:41,749 --> 00:15:43,414
but they forget to
do the nil case.

275
00:15:43,414 --> 00:15:44,540
Well, you aren't covering

276
00:15:44,540 --> 00:15:46,910
all the possibilities.
If you do that.

277
00:15:46,910 --> 00:15:49,039
I see peak cases where there was

278
00:15:49,039 --> 00:15:52,280
the nil case and two
cons is at the front.

279
00:15:52,280 --> 00:15:53,990
And somebody said, Why do I

280
00:15:53,990 --> 00:15:56,000
need the case for a
list of length one?

281
00:15:56,000 --> 00:15:58,549
Well, because if you've got
two constants at the front,

282
00:15:58,549 --> 00:16:01,115
you have at least two
elements in the list.

283
00:16:01,115 --> 00:16:02,990
And therefore you
need to worry about

284
00:16:02,990 --> 00:16:04,790
what if there's only one
element in the list?

285
00:16:04,790 --> 00:16:06,169
So you need a one case.

286
00:16:06,169 --> 00:16:08,809
Sometimes people have
a perfectly good case

287
00:16:08,809 --> 00:16:10,294
for the variable excess in it.

288
00:16:10,294 --> 00:16:12,260
It works for every single list.

289
00:16:12,260 --> 00:16:13,924
But in front of it they add

290
00:16:13,924 --> 00:16:15,845
a special case for
the empty list.

291
00:16:15,845 --> 00:16:21,739
Why do they do that? Anybody now?

292
00:16:22,590 --> 00:16:26,170
So very rarely they're doing that

293
00:16:26,170 --> 00:16:27,640
because empty list behaves

294
00:16:27,640 --> 00:16:30,024
differently than everything else.

295
00:16:30,024 --> 00:16:32,650
Okay, but that's a very
unusual situation.

296
00:16:32,650 --> 00:16:34,270
What you should always
check is the empty list

297
00:16:34,270 --> 00:16:36,175
behaves the same as
everything else.

298
00:16:36,175 --> 00:16:40,315
So when people have one
line that looks like this,

299
00:16:40,315 --> 00:16:42,429
I'll just put them in
here for a moment.

300
00:16:42,429 --> 00:16:47,815
Write f of nil equals whatever.

301
00:16:47,815 --> 00:16:50,305
And one line that
looks like this,

302
00:16:50,305 --> 00:16:52,674
f of x cons xs equals,

303
00:16:52,674 --> 00:16:55,000
sorry, that of course
is what you should do.

304
00:16:55,000 --> 00:16:56,694
But every now and then,

305
00:16:56,694 --> 00:16:58,555
you'll have something
that looks like this.

306
00:16:58,555 --> 00:17:00,780
Just f of xs equals something.

307
00:17:00,780 --> 00:17:03,875
And they put in an
extra mine for now.

308
00:17:03,875 --> 00:17:10,949
Why do people do
that? Anybody know?

309
00:17:11,380 --> 00:17:17,689
Yes. Thought the function
doesn't faulty it.

310
00:17:17,689 --> 00:17:20,479
That's if you need a
special case for this,

311
00:17:20,479 --> 00:17:21,740
but they always does
the right thing.

312
00:17:21,740 --> 00:17:24,305
So right, here's an example.

313
00:17:24,305 --> 00:17:29,810
Par of xs.

314
00:17:29,810 --> 00:17:32,900
Is this.

315
00:17:32,900 --> 00:17:36,360
Just put a parentheses
around axes.

316
00:17:45,150 --> 00:17:48,085
Why is this? There we go.

317
00:17:48,085 --> 00:17:49,599
And let's say they put in

318
00:17:49,599 --> 00:17:54,100
a special case,
which is this one.

319
00:17:54,100 --> 00:17:56,439
Okay, why have people done that?

320
00:17:56,439 --> 00:17:59,540
Why would you write
the function that way?

321
00:18:02,160 --> 00:18:06,530
You've answered before, guess
hence up that over there.

322
00:18:09,510 --> 00:18:12,610
Because if you didn't have

323
00:18:12,610 --> 00:18:15,805
this line and we did
part of empty list,

324
00:18:15,805 --> 00:18:18,039
we would get, no,

325
00:18:18,039 --> 00:18:19,689
this is a list of characters.

326
00:18:19,689 --> 00:18:21,370
So we've got the empty
list of characters.

327
00:18:21,370 --> 00:18:23,184
So it would be open parenthesis

328
00:18:23,184 --> 00:18:25,179
and then nothing and
then close parenthesis.

329
00:18:25,179 --> 00:18:26,954
So it would be exactly that.

330
00:18:26,954 --> 00:18:29,180
This does not change the answer.

331
00:18:29,180 --> 00:18:31,789
So what you'd want to do it
if it changed the answer,

332
00:18:31,789 --> 00:18:33,620
but here it doesn't
change the answer.

333
00:18:33,620 --> 00:18:36,209
So why have people done that?

334
00:18:36,250 --> 00:18:38,480
Why would you do such a thing?

335
00:18:38,480 --> 00:18:42,539
Yes. Sorry, speak up.

336
00:18:42,760 --> 00:18:46,175
To make the code more readable.

337
00:18:46,175 --> 00:18:49,520
Right? So making the code
more readable is a good idea.

338
00:18:49,520 --> 00:18:51,800
But in fact, this is
making the code less

339
00:18:51,800 --> 00:18:55,024
readable because there's
more of it to do.

340
00:18:55,024 --> 00:18:56,480
And looking at that, I would take

341
00:18:56,480 --> 00:18:59,389
maybe it's doing something

342
00:18:59,389 --> 00:19:00,740
special for the empty list thing.

343
00:19:00,740 --> 00:19:02,090
You look at this when
you discover no,

344
00:19:02,090 --> 00:19:04,789
it's not doing anything
special for the empty list.

345
00:19:04,789 --> 00:19:07,250
But you want to design your code.

346
00:19:07,250 --> 00:19:09,440
So if you're not doing

347
00:19:09,440 --> 00:19:12,679
a definition by recursion where
you look at nil and cons.

348
00:19:12,679 --> 00:19:14,569
If you're just doing it on axes,

349
00:19:14,569 --> 00:19:16,189
which we do sometime,
you want it to

350
00:19:16,189 --> 00:19:19,110
work uniformly for everything.

351
00:19:19,390 --> 00:19:23,674
So you'd want to avoid
special cases like this.

352
00:19:23,674 --> 00:19:25,069
It's more to read,

353
00:19:25,069 --> 00:19:27,740
more to test, more to write.

354
00:19:27,740 --> 00:19:30,649
So why are people
doing it this way?

355
00:19:30,649 --> 00:19:33,410
Right when look over people's
shoulders and tutorials,

356
00:19:33,410 --> 00:19:34,895
about half people do it this way.

357
00:19:34,895 --> 00:19:36,230
Why are people doing it this way?

358
00:19:36,230 --> 00:19:41,869
Yes. To make the
code more efficient,

359
00:19:41,869 --> 00:19:43,580
actually, it makes the
code less efficient

360
00:19:43,580 --> 00:19:46,250
because you need to test
for a special case.

361
00:19:46,250 --> 00:19:49,070
It makes it slightly faster
in this special case.

362
00:19:49,070 --> 00:19:53,030
But since almost never are
things nil every other time,

363
00:19:53,030 --> 00:19:55,219
the pore stupid computers
that is saying is if

364
00:19:55,219 --> 00:19:58,309
VIP List No itself
the empty list.

365
00:19:58,309 --> 00:20:00,290
And that's a few more
milliseconds going on.

366
00:20:00,290 --> 00:20:01,534
So it actually, to,

367
00:20:01,534 --> 00:20:04,129
the suggested answer
was because it makes it

368
00:20:04,129 --> 00:20:05,329
more efficient that the answer is

369
00:20:05,329 --> 00:20:07,189
doing this makes
it less efficient.

370
00:20:07,189 --> 00:20:09,485
If I normally don't
talk about efficiency.

371
00:20:09,485 --> 00:20:11,164
So I should have given
a complete list.

372
00:20:11,164 --> 00:20:14,434
It makes it more to
write, more to read,

373
00:20:14,434 --> 00:20:18,349
harder to understand, more
to test, and less efficient.

374
00:20:18,349 --> 00:20:20,405
Sorry, I left that one out.

375
00:20:20,405 --> 00:20:22,159
Any other suggestions?

376
00:20:22,159 --> 00:20:31,430
Yes. What people

377
00:20:31,430 --> 00:20:32,719
are very good answer.

378
00:20:32,719 --> 00:20:34,610
People are doing it
by force of habit.

379
00:20:34,610 --> 00:20:36,470
And because they're
not used to treating

380
00:20:36,470 --> 00:20:38,750
the empty case as uniform,

381
00:20:38,750 --> 00:20:41,914
that they want to make
it into a special case.

382
00:20:41,914 --> 00:20:44,885
So people have force of
habit for doing this.

383
00:20:44,885 --> 00:20:46,459
I think that's a good answer.

384
00:20:46,459 --> 00:20:47,719
That's why people do
it. And I'm going to

385
00:20:47,719 --> 00:20:49,309
summarize that in
a different way.

386
00:20:49,309 --> 00:20:53,015
The reason why people
tend to put in this case,

387
00:20:53,015 --> 00:20:54,560
when they're writing things,

388
00:20:54,560 --> 00:20:59,915
is because they are
doing it wrong.

389
00:20:59,915 --> 00:21:02,524
And I've seen lots of you do it.

390
00:21:02,524 --> 00:21:04,039
It's a very natural habits for

391
00:21:04,039 --> 00:21:05,330
exactly the reason this person

392
00:21:05,330 --> 00:21:06,875
has had its force of habit.

393
00:21:06,875 --> 00:21:08,224
What does it do that advocate,

394
00:21:08,224 --> 00:21:09,740
it's good to think about what

395
00:21:09,740 --> 00:21:11,774
does it do on the empty case.

396
00:21:11,774 --> 00:21:14,590
But relay, right?
You don't need here.

397
00:21:14,590 --> 00:21:16,120
So if you've just
had an axis, right?

398
00:21:16,120 --> 00:21:17,590
If you don't have cons,

399
00:21:17,590 --> 00:21:20,725
if you don't need a
special base case

400
00:21:20,725 --> 00:21:22,089
and you put this in,

401
00:21:22,089 --> 00:21:24,505
always put a comment.

402
00:21:24,505 --> 00:21:34,389
I really need this
because it's different.

403
00:21:34,389 --> 00:21:36,399
I, and here it's not different.

404
00:21:36,399 --> 00:21:39,070
But if the answer was
right in that case,

405
00:21:39,070 --> 00:21:42,159
suppose to say I am empty, right,

406
00:21:42,159 --> 00:21:45,700
then it's different, right?

407
00:21:45,700 --> 00:21:47,650
And then always add
a comment like that.

408
00:21:47,650 --> 00:21:50,815
So I know you're thinking about
what you're doing, right.

409
00:21:50,815 --> 00:21:53,320
If you always add a comment for

410
00:21:53,320 --> 00:21:57,289
a case that seems to
be covered elsewhere,

411
00:21:57,289 --> 00:21:58,790
then you'll think about, wait,

412
00:21:58,790 --> 00:22:00,770
do I really need this case?

413
00:22:00,770 --> 00:22:04,054
Right? But the basic answer
to adding special cases

414
00:22:04,054 --> 00:22:07,474
for special situations
is don't do that.

415
00:22:07,474 --> 00:22:10,320
Make it work in general.

416
00:22:11,860 --> 00:22:16,220
Okay, end of rant.
That to function.

417
00:22:16,220 --> 00:22:18,499
So in this case, right
then those special cases,

418
00:22:18,499 --> 00:22:20,209
just one for each constructor.

419
00:22:20,209 --> 00:22:21,995
That's what you'd normally say.

420
00:22:21,995 --> 00:22:24,710
And then for the subparts
are of the same type.

421
00:22:24,710 --> 00:22:26,269
We have recursive calls.

422
00:22:26,269 --> 00:22:27,799
That's what you'd normally say.

423
00:22:27,799 --> 00:22:29,419
So for a variable,

424
00:22:29,419 --> 00:22:31,399
remember I said, well,
if you're given p or q,

425
00:22:31,399 --> 00:22:33,349
you need to know what p or q,

426
00:22:33,349 --> 00:22:35,209
r. That's what the
environment is.

427
00:22:35,209 --> 00:22:37,234
Four, so we'll look it
up in the environment,

428
00:22:37,234 --> 00:22:38,795
will check that in a minute.

429
00:22:38,795 --> 00:22:42,274
If it's f, just return false.

430
00:22:42,274 --> 00:22:44,854
If it's T, returns true.

431
00:22:44,854 --> 00:22:50,180
If it's not p, recursively
evaluate p, take its negation.

432
00:22:50,180 --> 00:22:52,220
If it's, or recursively

433
00:22:52,220 --> 00:22:54,980
evaluate p and q and
all of them together.

434
00:22:54,980 --> 00:22:56,870
If it's and recursively

435
00:22:56,870 --> 00:23:00,545
evaluate P and Q and
add them together.

436
00:23:00,545 --> 00:23:01,985
That's all there is to it.

437
00:23:01,985 --> 00:23:04,625
Notice that every time you
do recursive evaluation,

438
00:23:04,625 --> 00:23:07,590
we also pass in this environment.

439
00:23:07,830 --> 00:23:10,180
And then last we
need to say, well,

440
00:23:10,180 --> 00:23:11,815
how do I look up a variable?

441
00:23:11,815 --> 00:23:13,944
So you've got function
look up here.

442
00:23:13,944 --> 00:23:15,910
It takes a list of

443
00:23:15,910 --> 00:23:20,274
AB pairs and you give it
an a and it returns a B.

444
00:23:20,274 --> 00:23:22,525
So in our case, we're going
to give it an environment.

445
00:23:22,525 --> 00:23:25,420
Remember an environment
is a list of name

446
00:23:25,420 --> 00:23:28,959
Boolean pairs where
names are just strings.

447
00:23:28,959 --> 00:23:32,859
This EQ, EI here just means
whatever the Type a is,

448
00:23:32,859 --> 00:23:35,500
it must have equality
defined on it.

449
00:23:35,500 --> 00:23:39,250
Have we defined
equality on strings?

450
00:23:39,250 --> 00:23:41,995
Yes. So that's okay.

451
00:23:41,995 --> 00:23:44,770
So now how do we
look something up?

452
00:23:44,770 --> 00:23:49,650
We just say, let x prime
and y be bound to each.

453
00:23:49,650 --> 00:23:51,394
Pair in this list.

454
00:23:51,394 --> 00:23:54,290
So x primes the first
element of the pair wise,

455
00:23:54,290 --> 00:23:58,159
the second we do this once
for each pair in the list.

456
00:23:58,159 --> 00:24:01,759
And if x and x prime are
the same, we found it.

457
00:24:01,759 --> 00:24:03,919
So we just return y.

458
00:24:03,919 --> 00:24:05,330
So now we've got the list of

459
00:24:05,330 --> 00:24:07,730
every y for where

460
00:24:07,730 --> 00:24:10,130
the first thing in the
list has the same name.

461
00:24:10,130 --> 00:24:13,429
Now, we want each name
to appear once, right?

462
00:24:13,429 --> 00:24:15,395
P is true, Q is false.

463
00:24:15,395 --> 00:24:19,550
We don't want to do something
like P is true. Q is false.

464
00:24:19,550 --> 00:24:20,795
P is false.

465
00:24:20,795 --> 00:24:23,029
Because then we've
said twice what P is,

466
00:24:23,029 --> 00:24:25,594
we shouldn't do this, we
shouldn't even do P is true,

467
00:24:25,594 --> 00:24:27,515
P is true, Q is false.

468
00:24:27,515 --> 00:24:29,434
We only need to say at once.

469
00:24:29,434 --> 00:24:33,439
So we're checking that it
appears just once in the list.

470
00:24:33,439 --> 00:24:37,444
So the list, you have
exactly one thing in it.

471
00:24:37,444 --> 00:24:39,620
So we write it in
square brackets to me,

472
00:24:39,620 --> 00:24:43,864
this is a list of length one
and X is its sole element.

473
00:24:43,864 --> 00:24:46,159
And then we return
that soil element.

474
00:24:46,159 --> 00:24:51,480
So then if we too, right,

475
00:25:01,200 --> 00:25:05,875
It's told us that
right. There we go.

476
00:25:05,875 --> 00:25:11,274
So I think we've gotten
environment and 0, we do.

477
00:25:11,274 --> 00:25:15,130
So that says a is
false and B is false.

478
00:25:15,130 --> 00:25:20,694
And now what happens if
we evaluate p 0 and n 0?

479
00:25:20,694 --> 00:25:25,270
What should we get as our
answer? Let's find it out.

480
00:25:25,270 --> 00:25:27,804
So a is going to be what?

481
00:25:27,804 --> 00:25:29,949
Please don't all answer at once.

482
00:25:29,949 --> 00:25:31,854
It really makes it
difficult for everybody.

483
00:25:31,854 --> 00:25:33,384
Let's try that again.

484
00:25:33,384 --> 00:25:36,219
So we've got here, a
is false, B is false.

485
00:25:36,219 --> 00:25:37,630
I now have a point.
Stupid computer

486
00:25:37,630 --> 00:25:39,270
is going to evaluate things.

487
00:25:39,270 --> 00:25:41,509
And the first thing
it sees is this,

488
00:25:41,509 --> 00:25:45,139
or there's an, or, it's an OR.

489
00:25:45,139 --> 00:25:46,910
Okay. Great way.

490
00:25:46,910 --> 00:25:48,679
Totally different
task that was shown.

491
00:25:48,679 --> 00:25:51,544
Okay, wait, let's just do here.

492
00:25:51,544 --> 00:25:54,500
It's, it's this or right.

493
00:25:54,500 --> 00:25:57,784
So the P bit is going
to be this one.

494
00:25:57,784 --> 00:26:00,185
And the cubit, it's
going to be this one.

495
00:26:00,185 --> 00:26:02,510
And then it looks at the PPE that

496
00:26:02,510 --> 00:26:06,649
and what do we do if the pivot,

497
00:26:06,649 --> 00:26:09,305
we evaluate it using

498
00:26:09,305 --> 00:26:11,299
the same environment
that was the one that

499
00:26:11,299 --> 00:26:13,549
says a is false and B is false.

500
00:26:13,549 --> 00:26:16,940
Okay? So we're going
to evaluate this.

501
00:26:16,940 --> 00:26:18,679
Let's see what's there
or what's an end,

502
00:26:18,679 --> 00:26:20,389
okay, it matches this line here,

503
00:26:20,389 --> 00:26:23,464
it's an and P is
going to be var a,

504
00:26:23,464 --> 00:26:25,790
and q is going to be var b.

505
00:26:25,790 --> 00:26:27,874
And then we're going to evaluate

506
00:26:27,874 --> 00:26:30,845
IEP and is the same as before.

507
00:26:30,845 --> 00:26:34,235
Okay, so now I'm evaluating
P. Here's var a,

508
00:26:34,235 --> 00:26:36,800
so that's this line here.

509
00:26:36,800 --> 00:26:39,259
Oh, okay.

510
00:26:39,259 --> 00:26:45,095
So X is going to be a and
I'm looking up at in E,

511
00:26:45,095 --> 00:26:48,875
and E is a is false
and B is false.

512
00:26:48,875 --> 00:26:52,894
I wonder what looking
up and acts as a.

513
00:26:52,894 --> 00:26:55,970
So I'm going to look at a and
a is false and B is false.

514
00:26:55,970 --> 00:26:57,020
I wonder what answer?

515
00:26:57,020 --> 00:26:58,625
Oh God, I have no idea.

516
00:26:58,625 --> 00:27:01,975
I'm a supercomputer. I just
do what it tells me to sweat.

517
00:27:01,975 --> 00:27:03,694
It tells me to is.

518
00:27:03,694 --> 00:27:06,125
Wait, wait. That's
a list of things.

519
00:27:06,125 --> 00:27:09,830
Was the case nobody
potent in no case.

520
00:27:09,830 --> 00:27:11,390
Does the computer ever say that?

521
00:27:11,390 --> 00:27:13,235
No, it doesn't care.

522
00:27:13,235 --> 00:27:16,369
Right? It just says,
Oh, okay, so x,

523
00:27:16,369 --> 00:27:20,209
y's, that gets down to
a list of AB pairs.

524
00:27:20,209 --> 00:27:22,295
It's this list right here.

525
00:27:22,295 --> 00:27:23,930
That's what XYZ is.

526
00:27:23,930 --> 00:27:28,414
And x that gets that
compound to a, okay?

527
00:27:28,414 --> 00:27:30,574
So I just copy this out,

528
00:27:30,574 --> 00:27:32,450
except everytime X appears,

529
00:27:32,450 --> 00:27:33,920
I'll replace it by a.

530
00:27:33,920 --> 00:27:36,619
And every time XYZ appears,

531
00:27:36,619 --> 00:27:39,110
I'll replace it by
the list I was given.

532
00:27:39,110 --> 00:27:44,730
So this will be and it should
copy out the V as well.

533
00:27:44,830 --> 00:27:49,019
Alright, so just copy
that out like this.

534
00:27:52,150 --> 00:28:02,339
And this is m 0 and this
is a is equal to x prime.

535
00:28:02,830 --> 00:28:06,840
And then it will get
the answer, which is,

536
00:28:07,600 --> 00:28:13,745
what will the answer be?
K, we'll take a vote.

537
00:28:13,745 --> 00:28:16,430
How many people think
the answer is true?

538
00:28:16,430 --> 00:28:19,700
How many people think
the answer is false?

539
00:28:19,700 --> 00:28:24,239
Okay, let's see if
democracy is correct.

540
00:28:24,730 --> 00:28:28,745
Boo variable not in
scope the right.

541
00:28:28,745 --> 00:28:31,579
I haven't defined V here,

542
00:28:31,579 --> 00:28:32,900
so it doesn't know
what to do with these.

543
00:28:32,900 --> 00:28:36,094
So that's fine. Let's
just do the same line.

544
00:28:36,094 --> 00:28:38,059
Will take the V out.

545
00:28:38,059 --> 00:28:40,384
Now what's this going to return?

546
00:28:40,384 --> 00:28:41,990
It's going to return a list.

547
00:28:41,990 --> 00:28:43,549
What listed will it return?

548
00:28:43,549 --> 00:28:46,174
How many people think
the empty list?

549
00:28:46,174 --> 00:28:49,130
How many people think
the list containing true

550
00:28:49,130 --> 00:28:51,934
and true to truth?

551
00:28:51,934 --> 00:28:55,175
How may people think list's
containing one true?

552
00:28:55,175 --> 00:28:58,460
I make people think the
list containing one false.

553
00:28:58,460 --> 00:29:00,995
Okay, lots of one falses.

554
00:29:00,995 --> 00:29:03,215
And that indeed is
what it returned.

555
00:29:03,215 --> 00:29:08,390
Why? So right, the first time
around x prime will be a,

556
00:29:08,390 --> 00:29:10,984
y will be false.

557
00:29:10,984 --> 00:29:13,850
A x prime will be bound to a.

558
00:29:13,850 --> 00:29:16,984
So a is the same as a.

559
00:29:16,984 --> 00:29:20,224
So it returns a list without
wine it which is false.

560
00:29:20,224 --> 00:29:23,360
Then the next time
around it's B and false.

561
00:29:23,360 --> 00:29:26,270
So this is B, this is false,

562
00:29:26,270 --> 00:29:28,970
and a equals B is

563
00:29:28,970 --> 00:29:30,499
false or that element doesn't

564
00:29:30,499 --> 00:29:32,599
appear in the final
list, it's filtered out.

565
00:29:32,599 --> 00:29:35,164
So we just get one
thing which is false.

566
00:29:35,164 --> 00:29:39,749
And then v is defined by.

567
00:29:42,840 --> 00:29:45,910
So if we say v of the list false,

568
00:29:45,910 --> 00:29:47,695
what are we going to get?

569
00:29:47,695 --> 00:29:53,065
Just false. Okay? Again, it's
worth pointing out, right?

570
00:29:53,065 --> 00:29:54,475
This is here because it says,

571
00:29:54,475 --> 00:29:57,789
I want a list of just one thing.

572
00:29:57,789 --> 00:30:00,789
This is here because it

573
00:30:00,789 --> 00:30:04,089
says the type of the
argument is a list.

574
00:30:04,089 --> 00:30:07,089
Not necessarily just one
thing, right? It's a list.

575
00:30:07,089 --> 00:30:10,360
It could be a list
of a thousand pairs,

576
00:30:10,360 --> 00:30:11,920
as long as the first thing has

577
00:30:11,920 --> 00:30:13,704
type a and the second
thing has type B.

578
00:30:13,704 --> 00:30:15,504
In our case, this
would be a string

579
00:30:15,504 --> 00:30:17,319
and this would be a Boolean.

580
00:30:17,319 --> 00:30:24,144
So this means a
list of any length.

581
00:30:24,144 --> 00:30:27,565
But here it stands for
a list of length one.

582
00:30:27,565 --> 00:30:30,279
So I've seen some people
get confused about that.

583
00:30:30,279 --> 00:30:33,699
So in a tight
brackets mean a list,

584
00:30:33,699 --> 00:30:35,289
but in a pattern,

585
00:30:35,289 --> 00:30:37,149
brackets around just one thing,

586
00:30:37,149 --> 00:30:39,849
mean our list of length one.

587
00:30:39,849 --> 00:30:42,249
And that's the only place
you use brackets if you

588
00:30:42,249 --> 00:30:44,680
want a list of some
specific length.

589
00:30:44,680 --> 00:30:47,890
So it might be bracket x
will not be bracket x, y,

590
00:30:47,890 --> 00:30:50,304
but it's going to give you a
list of a specific length,

591
00:30:50,304 --> 00:30:52,615
not an arbitrary list.

592
00:30:52,615 --> 00:30:55,209
Some people just say, oh,
put brackets around it.

593
00:30:55,209 --> 00:30:58,879
That will mean it's list.
No, do not do that.

594
00:31:00,630 --> 00:31:07,409
Okay. So are people
clear on how eval works?

595
00:31:07,409 --> 00:31:10,499
So the next step

596
00:31:11,380 --> 00:31:16,474
is we want to get the computer
to do our homework for us.

597
00:31:16,474 --> 00:31:19,040
So what we're going to do, oh,

598
00:31:19,040 --> 00:31:21,239
notice by the way,

599
00:31:22,240 --> 00:31:25,189
what is this here for?

600
00:31:25,189 --> 00:31:28,620
Why did I put that
in the program?

601
00:31:32,500 --> 00:31:35,000
Nobody has any idea.

602
00:31:35,000 --> 00:31:42,475
Yeah. Well, it just
returns a Boolean.

603
00:31:42,475 --> 00:31:45,030
It returns true or false.

604
00:31:48,850 --> 00:31:51,619
Perfect answer.

605
00:31:51,619 --> 00:31:55,355
Like the reason this
is here, it's a test.

606
00:31:55,355 --> 00:31:58,100
And I clearly went

607
00:31:58,100 --> 00:32:00,650
through and tested
the code once, right.

608
00:32:00,650 --> 00:32:02,929
And clearly I'm perfect.

609
00:32:02,929 --> 00:32:04,759
So the first time I wrote
the code, It was right.

610
00:32:04,759 --> 00:32:07,849
I never needed to alter it again.

611
00:32:07,849 --> 00:32:09,844
Okay. So even for me,

612
00:32:09,844 --> 00:32:11,960
that is not true, right?

613
00:32:11,960 --> 00:32:14,929
I have to change the code
again and again and again.

614
00:32:14,929 --> 00:32:16,400
And of course having changed,

615
00:32:16,400 --> 00:32:18,695
I'd want to test it still, right?

616
00:32:18,695 --> 00:32:22,375
So by writing the test here, y,

617
00:32:22,375 --> 00:32:24,949
all I need to do is run

618
00:32:24,949 --> 00:32:27,920
test prop and make sure
that that returns true.

619
00:32:27,920 --> 00:32:30,779
That's designed to return true.

620
00:32:38,830 --> 00:32:41,210
So you put tests in

621
00:32:41,210 --> 00:32:44,329
your code so that when
you change the code,

622
00:32:44,329 --> 00:32:46,100
you can do it over again.

623
00:32:46,100 --> 00:32:47,869
Okay, it's really important to

624
00:32:47,869 --> 00:32:49,280
be putting, testing your code.

625
00:32:49,280 --> 00:32:50,840
You will be marked on this,

626
00:32:50,840 --> 00:32:52,430
on the final, right,

627
00:32:52,430 --> 00:32:54,200
on the final, I will
expect you to do

628
00:32:54,200 --> 00:32:56,270
this sort of thing
with your code.

629
00:32:56,270 --> 00:32:58,939
And on the final, you will
want to do this sort of

630
00:32:58,939 --> 00:33:00,200
thing with your code because you

631
00:33:00,200 --> 00:33:01,865
want the final to be right.

632
00:33:01,865 --> 00:33:03,754
How do you make it right?

633
00:33:03,754 --> 00:33:09,660
Test it should include tests
like this in your code.

634
00:33:12,760 --> 00:33:16,099
And in fact, I put it in
the same form as things are

635
00:33:16,099 --> 00:33:20,069
used for quick check
on purpose so that if

636
00:33:28,330 --> 00:33:32,209
no, go away.

637
00:33:32,209 --> 00:33:39,664
So I can say quick
check, test, PRP.

638
00:33:39,664 --> 00:33:41,240
And it will say, okay,

639
00:33:41,240 --> 00:33:43,385
passed one test, right?

640
00:33:43,385 --> 00:33:46,565
It normally, remember it says
it's passed a 100 tests.

641
00:33:46,565 --> 00:33:48,350
But quick check is
clever enough to know

642
00:33:48,350 --> 00:33:50,210
that if you gave it no arguments,

643
00:33:50,210 --> 00:33:52,129
it's going to return the
same Boolean every times.

644
00:33:52,129 --> 00:33:55,115
It just needs to run this
and check it returns true.

645
00:33:55,115 --> 00:33:57,514
So doing that is just
the same as saying,

646
00:33:57,514 --> 00:34:00,395
Well wait, what did test
prop returned was true.

647
00:34:00,395 --> 00:34:04,024
So I can just run test
prop. And yep, it's true.

648
00:34:04,024 --> 00:34:12,950
Okay. Now the next thing

649
00:34:12,950 --> 00:34:18,290
we're going to do is we want
to do our homework four.

650
00:34:18,290 --> 00:34:20,779
So that means we want
to check whether

651
00:34:20,779 --> 00:34:24,574
a formula is a tautology
or unsatisfiable.

652
00:34:24,574 --> 00:34:27,364
So if it's satisfiable,

653
00:34:27,364 --> 00:34:31,384
that means there is
some way to assign

654
00:34:31,384 --> 00:34:32,989
true and false to

655
00:34:32,989 --> 00:34:37,129
the different variables
that will give us,

656
00:34:37,129 --> 00:34:39,950
that will give us true.

657
00:34:39,950 --> 00:34:42,605
So what we want is to look at

658
00:34:42,605 --> 00:34:45,800
all possible ways of doing it.

659
00:34:45,800 --> 00:34:48,050
Ok, So we've got two variables.

660
00:34:48,050 --> 00:34:50,450
How many different
ways are there that we

661
00:34:50,450 --> 00:34:53,820
can assign true and false
to two different variables.

662
00:34:55,750 --> 00:34:57,860
The two possibilities for

663
00:34:57,860 --> 00:35:00,964
the first 12 possibilities
for the second one.

664
00:35:00,964 --> 00:35:03,410
So two times two is four.

665
00:35:03,410 --> 00:35:05,479
If we had three variables,

666
00:35:05,479 --> 00:35:08,160
how many possibilities
would there be?

667
00:35:09,370 --> 00:35:13,234
Two times two? I
need another hand.

668
00:35:13,234 --> 00:35:15,990
Times two is eight.

669
00:35:17,290 --> 00:35:20,255
So let's just check this out.

670
00:35:20,255 --> 00:35:21,800
So we're gonna give it a list of

671
00:35:21,800 --> 00:35:24,299
names that's going to give us,

672
00:35:26,290 --> 00:35:29,600
give us all the possibilities.

673
00:35:29,600 --> 00:35:33,509
So if we give it names a and b,

674
00:35:34,450 --> 00:35:37,100
right there, four
possibilities here,

675
00:35:37,100 --> 00:35:45,430
let's just check
the length, right?

676
00:35:45,430 --> 00:35:47,379
That, that was a
list of length four.

677
00:35:47,379 --> 00:35:48,909
And I'm actually
going to go back and

678
00:35:48,909 --> 00:35:50,469
edit it so you can
see what they are

679
00:35:50,469 --> 00:35:53,964
easily. Doesn't like that.

680
00:35:53,964 --> 00:36:02,799
Alright? Alright, what were

681
00:36:02,799 --> 00:36:06,550
the four things that list will
a is false and B is false.

682
00:36:06,550 --> 00:36:08,424
Next was a is false,

683
00:36:08,424 --> 00:36:10,494
and B is true.

684
00:36:10,494 --> 00:36:14,290
Then a is true and B is false.

685
00:36:14,290 --> 00:36:17,979
Last was a is true and B is true.

686
00:36:17,979 --> 00:36:23,570
Okay, those are the four
possibilities that it found.

687
00:36:28,860 --> 00:36:31,525
So how does it do that?

688
00:36:31,525 --> 00:36:34,854
So thus it returns an XB pair.

689
00:36:34,854 --> 00:36:38,004
So if the, if the list
has at least length one,

690
00:36:38,004 --> 00:36:41,845
that acts as the head
accesses the tail.

691
00:36:41,845 --> 00:36:44,559
And what it's gonna do
is Xs gets paired with

692
00:36:44,559 --> 00:36:48,565
b for each b from fall,

693
00:36:48,565 --> 00:36:49,659
the list false, true.

694
00:36:49,659 --> 00:36:52,719
So we'll start with false
and then we'll go to true.

695
00:36:52,719 --> 00:36:55,870
And then recursively
we do the same thing.

696
00:36:55,870 --> 00:36:59,605
So in the course of
evaluating this,

697
00:36:59,605 --> 00:37:04,105
we're going to evaluate ends
of this listed is just b.

698
00:37:04,105 --> 00:37:09,229
Sorry. The list containing
just the name b.

699
00:37:09,229 --> 00:37:12,079
And what's that going
to give us? Same thing.

700
00:37:12,079 --> 00:37:15,439
So be paired with false
and be paired with true.

701
00:37:15,439 --> 00:37:17,269
Wait for that to work.

702
00:37:17,269 --> 00:37:22,010
Okay, axis b, axes
is the empty list.

703
00:37:22,010 --> 00:37:24,920
Xs drawn from B and E be

704
00:37:24,920 --> 00:37:28,459
drawn from these and they'll
all possible environments.

705
00:37:28,459 --> 00:37:32,089
So we're going to say there's
one environment where there

706
00:37:32,089 --> 00:37:35,344
are no variables
bound to no values.

707
00:37:35,344 --> 00:37:38,480
So that's why this returns
the list of one thing,

708
00:37:38,480 --> 00:37:40,580
which is the empty list.

709
00:37:40,580 --> 00:37:44,569
We could've said empty, right?

710
00:37:44,569 --> 00:37:45,739
That would be the
obvious thing to

711
00:37:45,739 --> 00:37:47,239
say, then it won't work.

712
00:37:47,239 --> 00:37:49,219
If we change that to say empty,

713
00:37:49,219 --> 00:37:51,779
what will we get as the answer?

714
00:37:54,040 --> 00:37:56,419
Will get no things loaded

715
00:37:56,419 --> 00:37:59,099
because I've got
this drug curvature.

716
00:38:00,220 --> 00:38:02,629
Right? If I say empty there,

717
00:38:02,629 --> 00:38:04,099
what now do I get as the answer?

718
00:38:04,099 --> 00:38:09,140
If I do end of a,

719
00:38:09,140 --> 00:38:12,330
B, what will I get?

720
00:38:12,910 --> 00:38:21,289
A may know. Yep. We'll
get the empty list.

721
00:38:21,289 --> 00:38:25,130
Variables not in
scope and yes, it is.

722
00:38:25,130 --> 00:38:27,889
I just loaded it. Oh,
no, I didn't fail.

723
00:38:27,889 --> 00:38:29,090
No models or Oh, that's right.

724
00:38:29,090 --> 00:38:31,500
Didn't load. Okay, try again.

725
00:38:33,520 --> 00:38:42,425
And a, b, c. Why is that?

726
00:38:42,425 --> 00:38:44,539
Well, for to compute that, right,

727
00:38:44,539 --> 00:38:45,560
it had to compute ends,

728
00:38:45,560 --> 00:38:48,454
be back, gave us the empty list.

729
00:38:48,454 --> 00:38:50,509
So to compute that
it had to do this or

730
00:38:50,509 --> 00:38:52,999
that gave us the
empty list, right?

731
00:38:52,999 --> 00:38:55,909
So that's going to give
us empty because if we do

732
00:38:55,909 --> 00:39:01,969
be paired with a Boolean value B,

733
00:39:01,969 --> 00:39:09,260
cons onto e for each
be drawn from false,

734
00:39:09,260 --> 00:39:16,229
true had each E drawn from ends.

735
00:39:17,470 --> 00:39:21,649
The, the empty list of strings.

736
00:39:21,649 --> 00:39:23,330
But we get the empty list.

737
00:39:23,330 --> 00:39:26,599
The way to see this
is if you do x,

738
00:39:26,599 --> 00:39:33,600
y for each x drawn
from 123 and each y,

739
00:39:37,560 --> 00:39:41,119
how long is the
answer going to be?

740
00:39:41,940 --> 00:39:45,130
Nine? Because the three
possibilities for

741
00:39:45,130 --> 00:39:48,264
the first three possibilities
for the second.

742
00:39:48,264 --> 00:39:54,699
Yep. If you count that
up, that's 12345678.

743
00:39:54,699 --> 00:39:56,889
Yep. There nine
possibilities there.

744
00:39:56,889 --> 00:40:07,850
So if I do, I know
it's boring y-type.

745
00:40:08,340 --> 00:40:11,890
Now, how long is the
answer list going to be?

746
00:40:11,890 --> 00:40:16,059
Six? Cuz there's three
possibilities for the first slot,

747
00:40:16,059 --> 00:40:18,710
the only two for the second.

748
00:40:18,750 --> 00:40:25,645
And now how long is the
answer going to be?

749
00:40:25,645 --> 00:40:29,499
Three by three different

750
00:40:29,499 --> 00:40:30,939
possibilities for the first slot,

751
00:40:30,939 --> 00:40:32,724
but only one for the second.

752
00:40:32,724 --> 00:40:41,990
And now how longest the
answer list going to be 0?

753
00:40:42,000 --> 00:40:44,110
And you notice that in general,

754
00:40:44,110 --> 00:40:49,419
if this list has length m
and this one has length n,

755
00:40:49,419 --> 00:40:54,130
the total thing will
be m times n, right?

756
00:40:54,130 --> 00:40:56,395
So if one of them has length 0,

757
00:40:56,395 --> 00:40:58,720
the result will have length 0.

758
00:40:58,720 --> 00:41:03,049
And by the way, the name for
this sort of thing is it's

759
00:41:03,049 --> 00:41:07,594
called the Cartesian
product of two lists.

760
00:41:07,594 --> 00:41:09,290
And the important thing
to note there is it

761
00:41:09,290 --> 00:41:10,984
has product in it,

762
00:41:10,984 --> 00:41:12,740
which is a hint, The length of

763
00:41:12,740 --> 00:41:14,269
the result is the product

764
00:41:14,269 --> 00:41:16,264
of the lengths of the arguments.

765
00:41:16,264 --> 00:41:24,109
Okay? It's called Cartesian
in honor of re ne Descartes.

766
00:41:24,109 --> 00:41:26,939
We did interesting
things with pairs.

767
00:41:28,870 --> 00:41:33,185
So, okay.

768
00:41:33,185 --> 00:41:41,389
So now if we do something
like ends of a,

769
00:41:41,389 --> 00:41:47,710
B, B, C, D,

770
00:41:47,710 --> 00:41:52,060
it's really hard to
type to misspell be.

771
00:41:52,060 --> 00:41:54,939
Ok. How long is the list
from this one gonna

772
00:41:54,939 --> 00:42:01,629
Bay site

773
00:42:01,629 --> 00:42:05,950
16 to 42 possibilities

774
00:42:05,950 --> 00:42:07,119
for a two for B,

775
00:42:07,119 --> 00:42:08,679
two for C2 for day.

776
00:42:08,679 --> 00:42:10,030
Two times two times,

777
00:42:10,030 --> 00:42:13,189
two times two is 16.

778
00:42:13,860 --> 00:42:15,939
Outright. You have to use

779
00:42:15,939 --> 00:42:18,619
the right definition
that would outweigh.

780
00:42:34,500 --> 00:42:36,580
I don't want to
count it. I'll get

781
00:42:36,580 --> 00:42:38,064
the computer to count it for me.

782
00:42:38,064 --> 00:42:41,050
Yes, has 16 elements.

783
00:42:41,050 --> 00:42:43,555
Okay, do people
see how that work?

784
00:42:43,555 --> 00:42:47,649
And very importantly, we
need here a list of length

785
00:42:47,649 --> 00:42:52,060
one because the product of
know things is one, right?

786
00:42:52,060 --> 00:42:53,845
Remember we learned
that for product,

787
00:42:53,845 --> 00:42:56,455
product of know things,
some of know things has 0.

788
00:42:56,455 --> 00:42:58,329
Product of know things is one.

789
00:42:58,329 --> 00:42:59,979
This is a kind of product.

790
00:42:59,979 --> 00:43:01,750
So we need a list of length one.

791
00:43:01,750 --> 00:43:03,129
And in particular,

792
00:43:03,129 --> 00:43:06,055
the empty list is exactly
what we want in this case.

793
00:43:06,055 --> 00:43:07,599
So it's really important to think

794
00:43:07,599 --> 00:43:10,509
through what you want
for the empty list.

795
00:43:10,509 --> 00:43:13,750
And notice here, right, we
cover all possibilities.

796
00:43:13,750 --> 00:43:17,554
Either it's an empty
list, is non-empty.

797
00:43:17,554 --> 00:43:20,389
So recovering all
the possibilities,

798
00:43:20,389 --> 00:43:23,344
as you'd expect for a
recursive definition.

799
00:43:23,344 --> 00:43:25,849
And no special case, right?

800
00:43:25,849 --> 00:43:27,230
This is just the base case,

801
00:43:27,230 --> 00:43:29,540
but you have to think
carefully about

802
00:43:29,540 --> 00:43:32,705
what the right answer
for the base case is.

803
00:43:32,705 --> 00:43:38,135
So now, right, so there's some,

804
00:43:38,135 --> 00:43:40,290
a couple of tests.

805
00:43:40,600 --> 00:43:47,189
And then you can just define
satisfiability very easily.

806
00:43:49,000 --> 00:43:55,550
Because you just, for each
possible environment,

807
00:43:55,550 --> 00:43:57,410
for all the names in p,

808
00:43:57,410 --> 00:44:02,390
you just evaluate P in one
of those environments.

809
00:44:02,390 --> 00:44:05,720
And if it works for any of
them than it satisfiable.

810
00:44:05,720 --> 00:44:08,884
So we guessed or them altogether.

811
00:44:08,884 --> 00:44:11,215
You can guess how you'd
vary this together.

812
00:44:11,215 --> 00:44:17,690
Topology. And then we had
to particular formulas,

813
00:44:17,690 --> 00:44:19,340
right? P0 and P1.

814
00:44:19,340 --> 00:44:26,730
So remember, P 0 is that,
is that satisfiable.

815
00:44:27,520 --> 00:44:30,139
But the satisfying value of that,

816
00:44:30,139 --> 00:44:32,159
there are actually several.

817
00:44:33,100 --> 00:44:36,469
So if a is false and B is false,

818
00:44:36,469 --> 00:44:39,154
what is the value
of this expression?

819
00:44:39,154 --> 00:44:45,364
So false and false is false
or what's not a false?

820
00:44:45,364 --> 00:44:47,885
What's not a false?

821
00:44:47,885 --> 00:44:50,345
And what's true and true.

822
00:44:50,345 --> 00:44:52,819
And thingy or true is true.

823
00:44:52,819 --> 00:44:55,415
So it should be satisfiable.

824
00:44:55,415 --> 00:44:58,175
And if we do satisfiable,

825
00:44:58,175 --> 00:45:02,909
p 0, it says yep, it was true.

826
00:45:03,220 --> 00:45:09,289
And P1 is either a,

827
00:45:09,289 --> 00:45:13,590
it's both a and naught
a is that satisfiable?

828
00:45:13,630 --> 00:45:16,070
Really? Let's just check.

829
00:45:16,070 --> 00:45:17,944
So if a is true, this is true.

830
00:45:17,944 --> 00:45:21,664
Ha, ha, we're on our way
and what's not true?

831
00:45:21,664 --> 00:45:24,169
False, so true and
false as false.

832
00:45:24,169 --> 00:45:25,624
Okay, that one didn't work,

833
00:45:25,624 --> 00:45:29,239
but maybe the other one
will work if a is false.

834
00:45:29,239 --> 00:45:31,699
So if a is true, now we did that.

835
00:45:31,699 --> 00:45:36,259
When if a is false, this
is false and false.

836
00:45:36,259 --> 00:45:38,179
False and anything
is false, okay,

837
00:45:38,179 --> 00:45:39,770
we don't even need
to look at that one.

838
00:45:39,770 --> 00:45:40,954
It's going to be false.

839
00:45:40,954 --> 00:45:42,919
So it's not satisfiable.

840
00:45:42,919 --> 00:45:52,039
And indeed up, let's try P1,

841
00:45:52,039 --> 00:45:54,389
that would work
better, wouldn't it?

842
00:45:55,330 --> 00:45:58,489
So that's false as we expected.

843
00:45:58,489 --> 00:46:00,260
Notice it's very important to

844
00:46:00,260 --> 00:46:05,039
type one rather than 0
when you want to type one.

845
00:46:06,100 --> 00:46:09,154
And then, right, we're at time.

846
00:46:09,154 --> 00:46:10,339
But just to see right,

847
00:46:10,339 --> 00:46:12,259
we have this other
function names which

848
00:46:12,259 --> 00:46:14,599
returned all the
names in the term.

849
00:46:14,599 --> 00:46:18,004
You can go back and study
that one if you want.

850
00:46:18,004 --> 00:46:21,065
Okay, so that's all I
wanted to show you today.

851
00:46:21,065 --> 00:46:25,039
And I'm not going to wish
you good luck on the test

852
00:46:25,039 --> 00:46:27,110
tomorrow because I don't think

853
00:46:27,110 --> 00:46:29,315
luck should have
anything to do with it.

854
00:46:29,315 --> 00:46:32,459
I wish you good knowledge.
